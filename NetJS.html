<!DOCTYPE html>
<html>
<head>
  <title>Interactive Network Map</title>
  <link href="https://unpkg.com/vis-network/styles/vis-network.min.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <style type="text/css">
    /* Basic Reset & Body */
    body { font-family: Arial, sans-serif; margin: 0; height: 100vh; display: flex; flex-direction: column; font-size: 14px; background-color: #f4f7fc; }

    /* Header / Main Control Buttons */
    .main-control-buttons { padding: 10px; display: flex; gap: 10px; flex-wrap: wrap; align-items: center; width: 100%; background-color: #e9ecef; border-bottom: 1px solid #ced4da; box-sizing: border-box; }
    .main-control-buttons button, .main-control-buttons label { padding: 8px 12px; background-color: #007bff; color:white; border:none; border-radius:4px; cursor:pointer; font-size: 14px; line-height: normal; white-space: nowrap; }
    .main-control-buttons button:hover, .main-control-buttons label:hover { background-color: #0056b3; }
    .main-control-buttons input[type="file"] { display: none; }
    .main-control-buttons .spacer { margin-left: auto; }
    #btnClearDiagram { background-color: #ffc107; color: #212529; }
    #btnClearDiagram:hover { background-color: #e0a800; }
    #btnResetDiagram { background-color: #dc3545; }
    #btnResetDiagram:hover { background-color: #c82333; }
    #btnExportImageWithLegend { background-color: #17a2b8; }
    #btnExportImageWithLegend:hover { background-color: #138496; }

    /* App Layout (Sidebar + Main Content) */
    #app-container { display: flex; flex-grow: 1; height: calc(100vh - 60px); /* Adjust based on header height */ overflow: hidden; }

    /* Sidebar */
    #sidebar { width: 320px; /* Sidebar width */ height: 100%; background-color: #ffffff; border-right: 1px solid #ced4da; display: flex; flex-direction: column; box-shadow: 2px 0 5px rgba(0,0,0,0.1); }
    .sidebar-tabs { display: flex; border-bottom: 1px solid #ced4da; background-color: #f8f9fa; }
    .sidebar-tab-button { padding: 10px 12px; border: none; background: none; cursor: pointer; font-size: 0.9em; border-bottom: 3px solid transparent; flex-grow: 1; text-align: center; color: #495057; }
    .sidebar-tab-button:hover { background-color: #e9ecef; }
    .sidebar-tab-button.active { border-bottom-color: #007bff; font-weight: bold; color: #0056b3; background-color: #fff; }
    .sidebar-content { flex-grow: 1; overflow-y: auto; padding: 10px; }
    .tab-panel { display: none; /* Hidden by default */ flex-direction: column; gap: 15px; }
    .tab-panel.active { display: flex; /* Shown when active */ }

    /* Form Section Styling (Adjusted for Sidebar) */
    .form-section { padding: 12px; border: 1px solid #dee2e6; border-radius: 4px; background-color: #f8f9fa; /* Light background */ flex-shrink: 0; /* Prevent shrinking */ }
    .form-section h3 { margin-top: 0; margin-bottom: 10px; font-size: 1.1em; /* Slightly larger header */ color: #343a40; padding-bottom: 6px; border-bottom: 1px solid #ced4da;}
    .form-section label, .form-section input, .form-section select, .form-section button { display: block; margin-bottom: 8px; /* Increased spacing */ width: 100%; box-sizing: border-box; }
    .form-section input[type="text"], .form-section input[type="color"], .form-section input[type="number"], .form-section select { padding: 8px; /* Slightly larger padding */ border: 1px solid #ced4da; border-radius: 3px; font-size: 0.95em;}
    .form-section input[type="checkbox"] { width: auto; margin-right: 5px; vertical-align: middle;}
    .form-section label { margin-bottom: 4px; font-weight: 500; color: #495057; }
    .form-section label.inline-label { display: inline-block; width: auto; margin-bottom:0; font-weight: normal; }
    .form-section button { padding: 9px 12px; background-color: #5cb85c; color: white; border: none; border-radius: 3px; cursor: pointer; font-size:0.95em; }
    .form-section button:hover { background-color: #4cae4c; }
    .form-section button.update-btn { background-color: #f0ad4e; }
    .form-section button.update-btn:hover { background-color: #ec971f; }
    .form-section button.cancel-btn { background-color: #6c757d; margin-top: 5px;}
    .form-section button.cancel-btn:hover { background-color: #5a6268; }
    .override-controls { margin-top: 10px; padding-top: 10px; border-top: 1px solid #e9ecef; }
    .override-controls label { display: inline-block; margin-right: 10px;}

    /* Data Lists Styling (Adjusted for Sidebar) */
    #allListsMegaContainer { display: flex; flex-direction: column; gap: 10px; } /* Container for lists */
    .list-section { border: 1px solid #dee2e6; background-color: #fff; border-radius: 5px; display: flex; flex-direction: column; }
    .list-section h3 { margin:0; padding: 8px 10px; font-size: 1em; color: #343a40; background-color:#f8f9fa; border-bottom: 1px solid #dee2e6; cursor:pointer; display:flex; justify-content: space-between; align-items:center;}
    .list-section h3 .toggle-icon::before { content: '▼'; font-size:0.8em; margin-left:5px; }
    .list-section h3.collapsed .toggle-icon::before { content: '►'; }
    .list-content { padding: 8px; overflow-y: auto; max-height: 180px; /* Keep max height */ flex-grow: 1; background-color: #fff; border-bottom-left-radius: 4px; border-bottom-right-radius: 4px; }
    .list-content.collapsed { display: none; }

    /* List Item Styling (No major change needed) */
    .list-item, .mgmt-list-item { padding: 5px; border-bottom: 1px solid #eee; font-size: 0.85em; display: flex; justify-content: space-between; align-items: center; }
    .list-item:last-child, .mgmt-list-item:last-child { border-bottom: none; }
    .list-item-content, .mgmt-list-item-content { flex-grow: 1; display: flex; align-items: center; word-break: break-word; gap: 5px; }
    .list-item-actions, .mgmt-list-item-actions { white-space: nowrap; margin-left: 5px; }
    .mgmt-list-color-swatch { min-width:12px; width:12px; height:12px; border-radius:3px; display:inline-block; border:1px solid #777;}
    .legend-node-shape-box { width: 16px; height: 16px; margin-right: 6px; border-width: 2px; border-style: solid; display:inline-block; vertical-align: middle; background-color: #f0f0f0; }
    .list-item-actions button, .mgmt-list-item-actions button { font-size: 0.75em; padding: 2px 5px; margin-left: 5px; color:white; border:none; border-radius:3px; cursor:pointer; }
    .list-item-actions button.delete-btn, .mgmt-list-item-actions button.delete-btn { background-color: #d9534f; }
    .list-item-actions button.delete-btn:hover, .mgmt-list-item-actions button.delete-btn:hover { background-color: #c9302c; }
    .list-item-actions button.edit-btn, .mgmt-list-item-actions button.edit-btn { background-color: #5bc0de; margin-left:0; margin-right: 5px; }
    .list-item-actions button.edit-btn:hover, .mgmt-list-item-actions button.edit-btn:hover { background-color: #31b0d5; }

    /* Settings Section Styling (Adjusted for Sidebar) */
    #appearancePhysicsSection { display: flex; flex-direction: column; gap: 10px; } /* Container for settings */
    .settings-group { display: flex; flex-direction: column; /* Stack columns vertically */ gap: 15px; padding: 12px; border: 1px solid #dee2e6; border-radius: 4px; background-color: #f8f9fa; }
    .settings-column { flex: 1; display: flex; flex-direction: column; gap: 10px; }
    .settings-column h4 { margin-top: 0; margin-bottom: 10px; font-size: 1em; color: #343a40; border-bottom: 1px solid #ced4da; padding-bottom: 4px;}
    .settings-control-group { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; /* Allow wrap on small sidebar */ }
    .settings-control-group label { flex-basis: 100px; /* Adjust basis */ text-align: left; margin-right: 0; font-size: 0.9em; white-space: normal; /* Allow label wrap */ }
    .settings-control-group input[type="number"], .settings-control-group select { flex-grow: 1; padding: 6px; width: auto; border-radius:3px; border:1px solid #ccc; max-width: none; /* Remove max-width */ min-width: 80px; /* Ensure minimum size */ }
    .settings-control-group input[type="checkbox"] { width: auto; margin-right: auto; order: -1; /* Put checkbox first */ margin-left: 10px; }
    .settings-column button { padding: 8px 12px; background-color: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 0.9em; align-self: flex-end; /* Align button right */ margin-top: 10px; }
    .settings-column button:hover { background-color: #218838; }

    /* Main Content Area (Network + Legend) */
    #main-content { flex-grow: 1; display: flex; height: 100%; padding: 10px; gap: 10px; background-color: #fff; /* White background for contrast */ }
    #mynetwork { flex-grow: 1; height: 100%; border: 1px solid #ced4da; background-color: #ffffff; }
    #legendContainer { width: 220px; /* Keep legend width */ height: fit-content; max-height: calc(100% - 20px); /* Max height relative to container */ padding: 8px; border: 1px solid #ced4da; background-color: #f9f9f9; border-radius: 5px; overflow-y: auto; flex-shrink: 0; /* Prevent shrinking */ }
    .legend-section { margin-bottom: 12px; }
    .legend-section h3 { margin-top: 0; margin-bottom: 6px; font-size: 0.9em; border-bottom: 1px solid #eee; padding-bottom: 3px; }
    .legend-item { display: flex; align-items: center; margin-bottom: 6px; }
    .legend-node-color-box { width: 16px; height: 16px; margin-right: 6px; border-width: 3px !important; border-style: solid; border-radius: 50%; } /* For Node Dept legend */
    .legend-edge-color-line { width: 20px; height: 3px; margin-right: 6px; border-radius: 2px; }
    .legend-text { font-size: 0.8em; }

    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div class="main-control-buttons">
    <button type="button" id="btnSaveJsonData">Save JSON</button>
    <input type="file" id="fileLoadJsonInput" accept=".json" style="display: none;">
    <label for="fileLoadJsonInput" id="btnLoadJsonDataProxy" role="button" tabindex="0">Load JSON</label>
    <button type="button" id="btnSaveTextData">Save Text</button>
    <input type="file" id="fileLoadTextInput" accept=".txt,.text,text/plain" style="display: none;">
    <label for="fileLoadTextInput" id="btnLoadTextDataProxy" role="button" tabindex="0">Load Text</label>
    <button type="button" id="btnExportImageWithLegend">Export Image with Legend</button>
    <div class="spacer"></div>
    <button type="button" id="btnClearDiagram">Clear Diagram</button>
    <button type="button" id="btnResetDiagram">Reset Diagram</button>
  </div>

  <div id="app-container">

    <div id="sidebar">
      <div class="sidebar-tabs">
        <button class="sidebar-tab-button active" data-tab="tab-edit">Edit</button>
        <button class="sidebar-tab-button" data-tab="tab-define">Define</button>
        <button class="sidebar-tab-button" data-tab="tab-lists">Lists</button>
        <button class="sidebar-tab-button" data-tab="tab-settings">Settings</button>
      </div>

      <div class="sidebar-content">
        <div id="tab-edit" class="tab-panel active">
          <div class="form-section" id="nodeFormSection">
            <h3 id="nodeFormTitle">Add/Edit Person</h3>
            <input type="hidden" id="editingNodeId">
            <label for="nodeLabel">Name/Label:</label> <input type="text" id="nodeLabel" placeholder="e.g., Alice Wonderland">
            <label for="nodeGroup">Department/Group:</label> <select id="nodeGroup"></select>
            <label for="nodeRole">Role:</label> <select id="nodeRole"></select>
            <button type="button" id="btnSaveNode">Add Person</button>
            <button type="button" id="btnCancelEditNode" class="cancel-btn hidden">Cancel Edit</button>
          </div>
          <div class="form-section" id="edgeFormSection">
            <h3 id="edgeFormTitle">Add/Edit Relationship</h3>
            <input type="hidden" id="editingEdgeId">
            <label for="edgeFrom">From Person:</label> <select id="edgeFrom"></select>
            <label for="edgeTo">To Person:</label> <select id="edgeTo"></select>
            <label for="edgeType">Relationship Type:</label> <select id="edgeType"></select>
            <label for="edgeStrength">Strength (Width/Physics):</label>
            <select id="edgeStrength">
                 <option value="weak">Weak</option>
                 <option value="medium" selected>Medium</option>
                 <option value="strong">Strong</option>
            </select>
            <div class="override-controls">
                <div> <label for="overrideArrowFrom" class="inline-label">Arrow From:</label>
                    <input type="checkbox" id="overrideArrowFrom">
                    <label for="overrideArrowTo" class="inline-label" style="margin-left:10px;">Arrow To:</label>
                    <input type="checkbox" id="overrideArrowTo">
                </div>
                <div style="margin-top: 5px;"> <label for="overrideShowLabel" class="inline-label">Show Label:</label>
                     <input type="checkbox" id="overrideShowLabel">
                </div>
            </div>
            <button type="button" id="btnSaveEdge">Add Relationship</button>
            <button type="button" id="btnCancelEditEdge" class="cancel-btn hidden">Cancel Edit</button>
          </div>
        </div>

        <div id="tab-define" class="tab-panel">
           <div class="form-section" id="manageNodeGroupForm">
                <h3 id="nodeGroupFormTitleMgmt">New/Edit Group Type</h3>
                <input type="hidden" id="editingNodeGroupKeyMgmt">
                <label for="newGroupName">Group Display Name:</label> <input type="text" id="newGroupName" placeholder="e.g., Sales">
                <label for="newGroupColor">Group Color:</label> <input type="color" id="newGroupColor" value="#e0e0e0">
                <button type="button" id="btnSaveNodeGroupMgmt">Add Group Type</button>
                <button type="button" id="btnCancelEditNodeGroupMgmt" class="cancel-btn hidden">Cancel Edit</button>
            </div>
            <div class="form-section" id="manageNodeRoleForm">
                <h3 id="nodeRoleFormTitleMgmt">New/Edit Role Type</h3>
                <input type="hidden" id="editingNodeRoleKeyMgmt">
                <label for="newNodeRoleName">Role Display Name:</label> <input type="text" id="newNodeRoleName" placeholder="e.g., Senior Developer">
                <label for="newNodeRoleColor">Role Outline Color:</label> <input type="color" id="newNodeRoleColor" value="#4A90E2">
                <label for="newNodeRoleShape">Node Shape:</label>
                <select id="newNodeRoleShape">
                    <option value="ellipse">Ellipse</option> <option value="circle" selected>Circle</option> <option value="database">Database</option> <option value="box">Box</option> <option value="text">Text</option> <option value="diamond">Diamond</option> <option value="star">Star</option> <option value="triangle">Triangle Up</option> <option value="triangleDown">Triangle Down</option> <option value="hexagon">Hexagon</option> <option value="square">Square</option>
                </select>
                <button type="button" id="btnSaveNodeRoleMgmt">Add Role Type</button>
                <button type="button" id="btnCancelEditNodeRoleMgmt" class="cancel-btn hidden">Cancel Edit</button>
            </div>
            <div class="form-section" id="manageRelTypeForm">
                <h3 id="relTypeFormTitleMgmt">New/Edit Relationship Type</h3>
                <input type="hidden" id="editingRelTypeIdMgmt">
                <label for="newRelTypeName">Type Display Label:</label> <input type="text" id="newRelTypeName" placeholder="e.g., Advises">
                <label for="newRelTypeColor">Type Color:</label> <input type="color" id="newRelTypeColor" value="#808080">
                <label for="newRelArrowStyle">Default Arrow Style:</label> <select id="newRelArrowStyle"> <option value="none">None</option> <option value="to">Directional (A → B)</option> <option value="bi" selected>Bi-Directional (A ↔ B)</option> </select>
                <div> <input type="checkbox" id="newRelShowLabel"> <label for="newRelShowLabel" class="inline-label">Show label on diagram by default</label> </div>
                <label for="newRelLabelAlign">Label Position (if shown):</label> <select id="newRelLabelAlign" disabled> <option value="middle" selected>Middle</option> <option value="top">Top</option> <option value="bottom">Bottom</option> <option value="horizontal">Horizontal</option> </select>
                <button type="button" id="btnSaveRelTypeMgmt">Add Relationship Type</button>
                <button type="button" id="btnCancelEditRelTypeMgmt" class="cancel-btn hidden">Cancel Edit</button>
            </div>
        </div>

        <div id="tab-lists" class="tab-panel">
          <div id="allListsMegaContainer">
              <div class="list-section" id="nodeListContainer"><h3>Current People <span class="toggle-icon"></span></h3><div class="list-content collapsed" id="nodeList"></div></div>
              <div class="list-section" id="edgeListContainer"><h3>Current Relationships <span class="toggle-icon"></span></h3><div class="list-content collapsed" id="edgeList"></div></div>
              <div class="list-section" id="nodeGroupMgmtListContainer"><h3>Manage Node Groups <span class="toggle-icon"></span></h3><div class="list-content collapsed" id="nodeGroupMgmtList"></div></div>
              <div class="list-section" id="nodeRoleMgmtListContainer"><h3>Manage Node Roles <span class="toggle-icon"></span></h3><div class="list-content collapsed" id="nodeRoleMgmtList"></div></div>
              <div class="list-section" id="relTypeMgmtListContainer"><h3>Manage Relationship Types <span class="toggle-icon"></span></h3><div class="list-content collapsed" id="relTypeMgmtList"></div></div>
          </div>
        </div>

        <div id="tab-settings" class="tab-panel">
           <div id="appearancePhysicsSection">
               <div class="settings-group">
                    <div class="settings-column">
                        <h4>Physics</h4>
                        <div class="settings-control-group">
                            <label for="physicsEnabledToggle">Enable Physics:</label>
                            <input type="checkbox" id="physicsEnabledToggle" checked>
                        </div>
                        <div class="settings-control-group">
                            <label for="physicsSpringConstantInput">Spring Stiffness:</label>
                            <input type="number" id="physicsSpringConstantInput" step="0.005" min="0">
                        </div>
                        <div class="settings-control-group">
                            <label for="physicsGravityInput">Central Gravity:</label>
                            <input type="number" id="physicsGravityInput" step="0.05" min="0">
                        </div>
                         <div class="settings-control-group">
                            <label for="physicsRepulsionInput">Node Repulsion:</label>
                            <input type="number" id="physicsRepulsionInput" step="100" max="0">
                        </div>
                        <div class="settings-control-group">
                            <label for="physicsSpringLengthInput">Ideal Spring Length:</label>
                            <input type="number" id="physicsSpringLengthInput" step="10" min="0">
                        </div>
                        <div class="settings-control-group">
                             <label for="physicsDampingInput">Damping (Friction):</label>
                             <input type="number" id="physicsDampingInput" step="0.01" min="0" max="1">
                        </div>
                        <button type="button" id="btnApplyPhysicsChanges">Apply Physics</button>
                    </div>

                    <div class="settings-column">
                         <h4>Appearance</h4>
                         <div class="settings-control-group">
                            <label for="edgeSpreadFactorInput">Edge Curve Factor (Parallel):</label>
                            <input type="number" id="edgeSpreadFactorInput" value="0.35" step="0.05" min="0" max="1">
                        </div>
                        <div class="settings-control-group">
                            <label for="edgeSmoothTypeInput">Edge Smooth Type:</label>
                            <select id="edgeSmoothTypeInput">
                                <option value="dynamic" selected>Dynamic</option>
                                <option value="continuous">Continuous</option>
                                <option value="curvedCW">Curved CW</option>
                                <option value="curvedCCW">Curved CCW</option>
                                <option value="cubicBezier">Cubic Bezier</option>
                            </select>
                        </div>
                        <div class="settings-control-group hidden" id="edgeSmoothRoundnessContainer">
                            <label for="edgeSmoothRoundnessInput">Smooth Roundness:</label>
                            <input type="number" id="edgeSmoothRoundnessInput" step="0.05" min="0" max="1" value="0.5">
                        </div>
                        <div class="settings-control-group">
                            <label for="appearanceNodeSizeInput">Node Size:</label>
                            <input type="number" id="appearanceNodeSizeInput" step="1" min="1">
                        </div>
                        <div class="settings-control-group">
                            <label for="appearanceNodeFontSizeInput">Node Font Size:</label>
                            <input type="number" id="appearanceNodeFontSizeInput" step="1" min="6">
                        </div>
                         <div class="settings-control-group">
                            <label for="appearanceEdgeBaseWidthInput">Edge Base Width:</label>
                            <input type="number" id="appearanceEdgeBaseWidthInput" step="0.5" min="0.5">
                        </div>
                         <button type="button" id="btnApplyAppearanceChanges">Apply Appearance</button>
                     </div>
               </div>
           </div>
        </div>
      </div>
    </div><div id="main-content">
      <div id="mynetwork"></div>
      <div id="legendContainer">
          <div class="legend-section" id="nodeLegend"><h3>Node Departments (Fill)</h3></div>
          <div class="legend-section" id="roleLegend"><h3>Node Roles (Shape & Outline)</h3></div>
          <div class="legend-section" id="edgeLegend"><h3>Relationship Types (Color)</h3></div>
      </div>
    </div></div><script type="text/javascript">
    console.log('SCRIPT EXECUTION STARTED. Vis object type:', typeof vis);

    // --- Global Data & State ---
    var nodes = null; var edges = null;
    var network = null; // Define network globally, initially null
    var nextNodeIdCounter = 1;
    var editingNodeId = null; var editingEdgeId = null;
    var editingNodeGroupKeyMgmt = null; var editingRelTypeIdMgmt = null;
    var editingNodeRoleKeyMgmt = null;
    var edgeSpreadFactor = 0.35; // Default spread factor stored globally

    // --- Deep Copy Helper ---
    function deepCopy(obj) {
        try {
            return JSON.parse(JSON.stringify(obj));
        } catch (e) {
            console.error("Deep copy failed:", e, obj);
            return null;
        }
    }

    // --- Initial Vis Network Options ---
    var visNetworkOptions = {
        edges:{
            font:{size:10},
            width: 2,
            smooth: {
                enabled: true,
                type: "dynamic", // Default smooth type
                roundness: 0.5   // Default roundness if applicable
            }
        },
        nodes:{
            shape:'circle',
            size: 20,
            font:{
                size: 14,
                face:'Arial'
            },
            widthConstraint:{maximum:150}, heightConstraint:{minimum:40},
            borderWidth: 2
        },
        physics:{
            enabled:true, // Physics enabled by default
            solver:'barnesHut',
            barnesHut:{
                springConstant: 0.04,
                centralGravity: 0.12,
                gravitationalConstant: -3000,
                springLength: 150,
                damping: 0.09
            }
        },
        interaction:{dragNodes:true,zoomView:true,hover:true},
        groups:{}
    };

    // --- Initial Data Definitions ---
    function getInitialNodeGroupStyles() { return { general: { name: 'General', color: { background: '#E0E0E0', border: darkenColor('#E0E0E0', 20) }, isDeletable: false }, leadership: { name: 'Leadership', color: { background: '#FFD700', border: darkenColor('#FFD700', 30) }, isDeletable: true }, }; }
    function getInitialEdgeTypeStyles() { return [ { id: 'collaborators', label: 'Collaborators', color: '#607D8B', arrowStyle: 'bi', showLabelOnDiagram: true, labelAlign: 'top', isDeletable: true }, { id: 'reports_to', label: 'Reports To', color: '#4CAF50', arrowStyle: 'to', showLabelOnDiagram: true, labelAlign: 'top', isDeletable: false }, { id: 'friends', label: 'Friends', color: '#FF69B4', arrowStyle: 'bi', showLabelOnDiagram: true, labelAlign: 'top', isDeletable: false }, { id: 'influences', label: 'Influences', color: '#9C27B0', arrowStyle: 'to', showLabelOnDiagram: true, labelAlign: 'top', isDeletable: true }, { id: 'mentors', label: 'Mentors', color: '#03A9F4', arrowStyle: 'to', showLabelOnDiagram: true, labelAlign: 'top', isDeletable: true } ]; }
    function getInitialNodeRoleStyles() { return { ic: { name: 'Individual Contributor', color: '#4A90E2', shape: 'circle', isDeletable: false }, manager_principal: { name: 'Manager/Principal', color: '#50E3C2', shape: 'circle', isDeletable: true }, director: { name: 'Director', color: '#F5A623', shape: 'circle', isDeletable: true }, vp: { name: 'Vice President', color: '#BD10E0', shape: 'circle', isDeletable: true }, division_president: { name: 'Division President', color: '#D0021B', shape: 'circle', isDeletable: true } }; }

    var nodeGroupStyles = getInitialNodeGroupStyles();
    var edgeTypeStyles = getInitialEdgeTypeStyles();
    var nodeRoleStyles = getInitialNodeRoleStyles();


    // --- Utility Functions ---
    function getRandomHexColor() { return '#'+Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'); }
    function darkenColor(h,p){try{h=h.replace(/^#/,'');if(h.length===3)h=h[0]+h[0]+h[1]+h[1]+h[2]+h[2];if(h.length!==6)return'#000000';let r=parseInt(h.substring(0,2),16),g=parseInt(h.substring(2,4),16),b=parseInt(h.substring(4,6),16);r=Math.max(0,Math.floor(r*(1-p/100)));g=Math.max(0,Math.floor(g*(1-p/100)));b=Math.max(0,Math.floor(b*(1-p/100)));return`#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`}catch(e){console.error("Error in darkenColor for hex:",h, e);return'#000000';}}
    function sanitizeKey(n){if(typeof n!=='string'||!n)return'invalid_key_'+Date.now();var k=n.toLowerCase().replace(/\s+/g,'_').replace(/[^\w-]/g,'');return k||'key_'+Date.now()}
    function mapArrowStyleToVisOptions(s){if(s==='to')return{to:{enabled:true,type:'arrow'}};if(s==='bi')return{to:{enabled:true,type:'arrow'},from:{enabled:true,type:'arrow'}};return {to:{enabled:false}, from:{enabled:false}};}
    function getEdgeWidthFromStrength(strength) {
        const baseWidth = (visNetworkOptions && visNetworkOptions.edges && typeof visNetworkOptions.edges.width === 'number') ? visNetworkOptions.edges.width : 2;
        if (strength === 'strong') return baseWidth * 2.5;
        if (strength === 'weak') return baseWidth * 0.5;
        return baseWidth;
    }
    function getEdgeLengthFromStrength(strength) {
        return undefined;
    }

    function getInitialVisNetworkOptions() {
        let initialOptions = {
             edges:{
                font:{size:10},
                width: 2,
                smooth: {
                    enabled: true,
                    type: "dynamic",
                    roundness: 0.5
                }
            },
             nodes:{ shape:'circle', size: 20, font:{ size: 14, face:'Arial' }, widthConstraint:{maximum:150}, heightConstraint:{minimum:40}, borderWidth: 2 },
             physics:{
                enabled:true,
                solver:'barnesHut',
                barnesHut:{ springConstant: 0.04, centralGravity: 0.12, gravitationalConstant: -3000, springLength: 150, damping: 0.09 }
            },
             interaction:{dragNodes:true,zoomView:true,hover:true},
             groups:{}
        };
         const initialGroupsData = getInitialNodeGroupStyles();
         initialOptions.groups = {};
         Object.keys(initialGroupsData).forEach(k => {
             const g = initialGroupsData[k];
             if (g && g.color) { initialOptions.groups[k] = { color: { background: g.color.background, border: g.color.border } }; }
         });
        return initialOptions;
    }


    // --- DOMContentLoaded ---
    document.addEventListener('DOMContentLoaded', function () {
        console.log('DOMContentLoaded. Vis available:', typeof vis !== 'undefined');
        if (typeof vis === 'undefined') { alert('Vis.js library not loaded!'); return; }
        if (typeof html2canvas === 'undefined') { console.warn('html2canvas library not loaded! Image export with legend will not work.'); }

        try {
            nodes = new vis.DataSet([]); edges = new vis.DataSet([]);
            let initialOptionsForNetwork = getInitialVisNetworkOptions();
            visNetworkOptions = deepCopy(initialOptionsForNetwork);

            var container = document.getElementById('mynetwork');
            if (!container) { throw new Error('Network container #mynetwork not found!'); }

            network = new vis.Network(container, { nodes: nodes, edges: edges }, initialOptionsForNetwork);
            console.log("Network initialized with options:", network.options);

            initializePhysicsControls();
            initializeAppearanceControls();
            setupControlsAndUI();
            loadDefaultDataset();

        } catch (e) {
            console.error('Init Error:', e);
            alert('App Initialization Error. Check console.');
        }
    });

    function setupControlsAndUI() {
        console.log('Setting up controls and UI elements.');
        try {
            var el;
            // Remove old top-level toggles if they existed
            // el = document.getElementById('allListsToggle'); if(el) el.removeEventListener(...); // etc.

            // Setup Sidebar Tabs
            document.querySelectorAll('.sidebar-tab-button').forEach(button => {
                button.addEventListener('click', function() {
                    const tabId = this.getAttribute('data-tab');

                    // Deactivate all buttons and panels
                    document.querySelectorAll('.sidebar-tab-button').forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.tab-panel').forEach(panel => panel.classList.remove('active'));

                    // Activate clicked button and corresponding panel
                    this.classList.add('active');
                    const activePanel = document.getElementById(tabId);
                    if(activePanel) {
                        activePanel.classList.add('active');
                    } else {
                        console.error("Tab panel not found:", tabId);
                    }
                });
            });

            // Form Buttons (Ensure IDs are still correct after moving)
            el = document.getElementById('btnSaveNode'); if(el) el.addEventListener('click', handleSaveNode);
            el = document.getElementById('btnCancelEditNode'); if(el) el.addEventListener('click', cancelEditNode);
            el = document.getElementById('btnSaveEdge'); if(el) el.addEventListener('click', handleSaveEdge);
            el = document.getElementById('btnCancelEditEdge'); if(el) el.addEventListener('click', cancelEditEdge);
            el = document.getElementById('btnSaveNodeGroupMgmt'); if(el) el.addEventListener('click', handleSaveNodeGroupMgmt);
            el = document.getElementById('btnCancelEditNodeGroupMgmt'); if(el) el.addEventListener('click', cancelEditNodeGroupMgmt);
            el = document.getElementById('btnSaveRelTypeMgmt'); if(el) el.addEventListener('click', handleSaveRelTypeMgmt);
            el = document.getElementById('btnCancelEditRelTypeMgmt'); if(el) el.addEventListener('click', cancelEditRelTypeMgmt);
            el = document.getElementById('btnSaveNodeRoleMgmt'); if(el) el.addEventListener('click', handleSaveNodeRoleMgmt);
            el = document.getElementById('btnCancelEditNodeRoleMgmt'); if(el) el.addEventListener('click', cancelEditNodeRoleMgmt);

            // File I/O & Export (Header - no changes needed here)
            el = document.getElementById('btnSaveJsonData'); if(el) el.addEventListener('click', handleSaveJsonData);
            el = document.getElementById('btnLoadJsonDataProxy'); if(el) el.addEventListener('click', function() { var fin = document.getElementById('fileLoadJsonInput'); if(fin) fin.click(); });
            el = document.getElementById('fileLoadJsonInput'); if(el) el.addEventListener('change', handleLoadJsonFileSelect);
            el = document.getElementById('btnSaveTextData'); if(el) el.addEventListener('click', handleSaveTextData);
            el = document.getElementById('btnLoadTextDataProxy'); if(el) el.addEventListener('click', function() { var fin=document.getElementById('fileLoadTextInput'); if(fin) fin.click(); });
            el = document.getElementById('fileLoadTextInput'); if(el) el.addEventListener('change', handleLoadJsonFileSelect); // Check if handler needs update
            el = document.getElementById('btnExportImageWithLegend'); if(el) el.addEventListener('click', exportDiagramWithLegend); // Uses updated function

            // Appearance/Physics Controls (Inside Settings Tab)
            el = document.getElementById('physicsEnabledToggle'); if(el) el.addEventListener('change', togglePhysicsInputsActiveState);
            el = document.getElementById('edgeSpreadFactorInput'); if (el) { el.addEventListener('change', handleEdgeSpreadChange); }
            el = document.getElementById('edgeSmoothTypeInput'); if(el) el.addEventListener('change', handleEdgeSmoothTypeChange);
            el = document.getElementById('btnApplyPhysicsChanges'); if (el) { el.addEventListener('click', applyPhysicsChanges); }
            el = document.getElementById('btnApplyAppearanceChanges'); if (el) { el.addEventListener('click', applyAppearanceChanges); }


            // Diagram Management Buttons (Header - no changes needed here)
            el = document.getElementById('btnClearDiagram'); if(el) el.addEventListener('click', handleClearDiagram);
            el = document.getElementById('btnResetDiagram'); if(el) el.addEventListener('click', handleResetDiagram);

            // List Collapse Toggles (Inside Lists Tab) - Keep this logic
            document.querySelectorAll('.list-section h3').forEach(function(h) {
                 h.addEventListener('click', function(e) {
                     if(e.target===this || (e.target.parentElement === this && e.target.classList.contains('toggle-icon'))) {
                         this.classList.toggle('collapsed');
                         var c = this.nextElementSibling;
                         if(c && c.classList.contains('list-content')) {
                             c.classList.toggle('collapsed');
                         }
                     }
                 });
            });
            // Initialize list collapse state (ensure they start collapsed if needed)
             document.querySelectorAll('.list-section h3').forEach(function(h) {
                 h.classList.add('collapsed');
                 var c = h.nextElementSibling;
                 if(c && c.classList.contains('list-content')) {
                     c.classList.add('collapsed');
                 }
             });


            // Other initializations
            var newRelShowLabelCheckbox = document.getElementById('newRelShowLabel');
            var newRelLabelAlignDropdown = document.getElementById('newRelLabelAlign');
            if (newRelShowLabelCheckbox) newRelShowLabelCheckbox.checked = false;
            if (newRelLabelAlignDropdown) newRelLabelAlignDropdown.disabled = true;
            if (newRelShowLabelCheckbox) { newRelShowLabelCheckbox.onchange = function() { if(newRelLabelAlignDropdown) newRelLabelAlignDropdown.disabled = !this.checked; }; }
            var edgeTypeDropdown = document.getElementById('edgeType');
            if (edgeTypeDropdown) { edgeTypeDropdown.addEventListener('change', updateEdgeOverridesFromType); }

            populateNodeGroupDropdown(); populateEdgeTypeDropdown(); populateNodeRoleDropdown();
            renderAllListsAndLegends(); updateNodeSelectors();

            console.log('setupControlsAndUI: Successfully completed.');
        } catch (e) { console.error('CRITICAL Error in setupControlsAndUI:', e); alert("Failed to setup UI controls. Check console."); }
    }

     function initializePhysicsControls() {
         console.log("Initializing physics controls");
         const initialOptions = getInitialVisNetworkOptions();
         if (!initialOptions || !initialOptions.physics || !initialOptions.physics.barnesHut) {
             console.error("Could not get initial physics defaults for controls!"); return;
         }
         const physicsDefaults = initialOptions.physics.barnesHut;
         const physicsEnabled = initialOptions.physics.enabled;
         try {
             const toggle = document.getElementById('physicsEnabledToggle');
             if (toggle) toggle.checked = physicsEnabled;
             else console.warn("Physics enable toggle not found");

             const springConst = document.getElementById('physicsSpringConstantInput');
             if(springConst) springConst.value = physicsDefaults.springConstant;
             const gravity = document.getElementById('physicsGravityInput');
             if(gravity) gravity.value = physicsDefaults.centralGravity;
             const repulsion = document.getElementById('physicsRepulsionInput');
             if(repulsion) repulsion.value = physicsDefaults.gravitationalConstant;
             const springLen = document.getElementById('physicsSpringLengthInput');
             if(springLen) springLen.value = physicsDefaults.springLength;
             const damping = document.getElementById('physicsDampingInput');
             if(damping) damping.value = physicsDefaults.damping;

             togglePhysicsInputsActiveState();
             console.log("Physics controls initialized. Enabled:", physicsEnabled, "Values:", physicsDefaults);
         } catch (e) { console.error("Error initializing physics controls elements:", e); }
     }

      function initializeAppearanceControls() {
         console.log("Initializing appearance controls");
         const initialOpts = getInitialVisNetworkOptions();
          if (!initialOpts || !initialOpts.nodes || !initialOpts.nodes.font || !initialOpts.edges || !initialOpts.edges.smooth) {
              console.error("Could not get initial appearance defaults for controls!"); return;
          }
         const nodeDefaults = initialOpts.nodes;
         const edgeDefaults = initialOpts.edges;
         try {
             const spreadFactor = document.getElementById('edgeSpreadFactorInput');
             if(spreadFactor) spreadFactor.value = edgeSpreadFactor;
             const nodeSize = document.getElementById('appearanceNodeSizeInput');
             if(nodeSize) nodeSize.value = nodeDefaults.size;
             const nodeFontSize = document.getElementById('appearanceNodeFontSizeInput');
             if(nodeFontSize) nodeFontSize.value = nodeDefaults.font.size;
             const edgeWidth = document.getElementById('appearanceEdgeBaseWidthInput');
             if(edgeWidth) edgeWidth.value = edgeDefaults.width;

             const smoothType = document.getElementById('edgeSmoothTypeInput');
             if(smoothType) smoothType.value = edgeDefaults.smooth.type || "dynamic";
             const smoothRoundness = document.getElementById('edgeSmoothRoundnessInput');
             if(smoothRoundness) smoothRoundness.value = edgeDefaults.smooth.roundness || 0.5;

            handleEdgeSmoothTypeChange();

            console.log("Appearance controls initialized.");
         } catch (e) { console.error("Error initializing appearance controls elements:", e); }
     }

    function togglePhysicsInputsActiveState() {
        const toggle = document.getElementById('physicsEnabledToggle');
        if (!toggle) return; // Exit if toggle not found
        const physicsEnabled = toggle.checked;
        const physicsInputs = [
            'physicsSpringConstantInput', 'physicsGravityInput',
            'physicsRepulsionInput', 'physicsSpringLengthInput', 'physicsDampingInput'
        ];
        physicsInputs.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.disabled = !physicsEnabled;
        });
    }

    function handleEdgeSmoothTypeChange() {
        const smoothTypeEl = document.getElementById('edgeSmoothTypeInput');
        const roundnessContainer = document.getElementById('edgeSmoothRoundnessContainer');
        if (!smoothTypeEl || !roundnessContainer) return; // Exit if elements not found

        const smoothType = smoothTypeEl.value;
        const typesWithRoundness = ['curvedCW', 'curvedCCW', 'cubicBezier'];

        if (typesWithRoundness.includes(smoothType)) {
            roundnessContainer.classList.remove('hidden');
        } else {
            roundnessContainer.classList.add('hidden');
        }
    }


    function loadDefaultDataset() {
        console.log("Loading default dataset...");
        try {
            if (!nodes || !edges) { console.error("Datasets not initialized."); return; }
            if (!edgeTypeStyles.find(t => t.id === 'friends') || !edgeTypeStyles.find(t => t.id === 'reports_to')) {
                console.warn("Default edge types missing. Re-initializing.");
                edgeTypeStyles = getInitialEdgeTypeStyles();
                populateEdgeTypeDropdown(); renderRelTypeMgmtList(); populateEdgeLegend();
            }
            if (!nodeGroupStyles['leadership'] || !nodeGroupStyles['general']) {
                console.warn("Default node group(s) missing. Re-initializing.");
                nodeGroupStyles = getInitialNodeGroupStyles();
                visNetworkOptions.groups = getInitialVisNetworkOptions().groups;
                if(network) network.setOptions({ groups: deepCopy(visNetworkOptions.groups) });
                populateNodeGroupDropdown(); renderNodeGroupMgmtList(); populateNodeLegend();
            }

            const buddyId = 'node_' + nextNodeIdCounter++;
            const johnId = 'node_' + nextNodeIdCounter++;
            const sallyId = 'node_' + nextNodeIdCounter++;
            const nodeDistance = 150;
            const nodeHeight = 130;

            addNodeInternal('Sally', 'general', 'ic', sallyId, nodeDistance / 2, 0);
            addNodeInternal('Buddy', 'general', 'ic', buddyId, 0, nodeHeight);
            addNodeInternal('John', 'leadership', 'ic', johnId, nodeDistance, nodeHeight);

            addEdgeInternal(buddyId, johnId, 'friends', true, true, 'strong', true);
            addEdgeInternal(buddyId, sallyId, 'reports_to', false, true, 'weak', true);
            addEdgeInternal(sallyId, johnId, 'reports_to', false, true, 'medium', true);

            console.log("Default dataset loaded.");
            renderNodeList(); renderEdgeList(); updateNodeSelectors();
            setTimeout(reapplySmoothToAllEdges, 100);
        } catch (e) {
            console.error("Error loading default dataset:", e);
            alert("An error occurred while loading the default data.");
        }
    }
    function addNodeInternal(originalLabel, groupKey, roleKey, nodeId, x, y) {
        var visNodeLabel = originalLabel.replace(/ /g, '\n');
        var groupInfo = nodeGroupStyles[groupKey] || nodeGroupStyles['general'];
        var roleInfo = nodeRoleStyles[roleKey] || nodeRoleStyles['ic'];
        var nodeTitle = originalLabel + ` (Dept: ${groupInfo.name}, Role: ${roleInfo.name})`;
        var nodeDataItem = {
            id: nodeId,
            label: visNodeLabel,
            group: groupKey,
            role: roleKey,
            title: nodeTitle,
            originalLabel: originalLabel,
            shape: roleInfo.shape || 'circle',
            borderWidth: 3,
            color: { border: roleInfo.color }
        };
        if (x !== undefined && y !== undefined) {
            nodeDataItem.x = x;
            nodeDataItem.y = y;
        }
        nodes.add(nodeDataItem);
    }

    function addEdgeInternal(fromNodeId, toNodeId, edgeTypeId, arrowFrom, arrowTo, strength = 'medium', showLabelOverride = undefined) {
        var type = edgeTypeStyles.find(t => t.id === edgeTypeId); if (!type) return;
        var edgeArrows = {};
        if (arrowFrom) edgeArrows.from = { enabled: true, type: 'arrow' };
        if (arrowTo) edgeArrows.to = { enabled: true, type: 'arrow' };
        var showLabelActual = (showLabelOverride !== undefined) ? showLabelOverride : (type.showLabelOnDiagram !== false);
        var edgeData = {
            from: fromNodeId, to: toNodeId,
            label: (showLabelActual ? type.label : undefined),
            font: { size: 10, align: (showLabelActual ? (type.labelAlign || 'middle') : undefined) },
            color: { color: type.color },
            arrows: edgeArrows,
            visjs_edge_type_id: type.id,
            strength: strength,
            width: getEdgeWidthFromStrength(strength),
            physics: { length: getEdgeLengthFromStrength(strength) },
        };
        edges.add(edgeData);
    }

    function renderAllListsAndLegends(){ try { renderNodeList();renderEdgeList();renderNodeGroupMgmtList();renderRelTypeMgmtList(); renderNodeRoleMgmtList(); populateNodeLegend();populateRoleLegend();populateEdgeLegend(); console.log("renderAllListsAndLegends completed."); } catch(e){console.error("Error in renderAllListsAndLegends:", e);}}

    // Removed toggleSection function as it's replaced by tab logic

    function handleClearDiagram() { if (!confirm("Are you sure you want to clear the diagram?\n\nThis will remove all people and relationships, but keep your defined Groups, Roles, and Relationship Types.")) return; console.log("Clearing diagram (nodes and edges)..."); try { if (nodes) nodes.clear(); if (edges) edges.clear(); nextNodeIdCounter = 1; renderNodeList(); renderEdgeList(); updateNodeSelectors(); console.log("Diagram cleared."); alert("Diagram cleared. Custom types remain."); } catch(e) { console.error("Error during diagram clear:", e); alert("An error occurred while clearing the diagram."); } }
    function handleResetDiagram() {
        if (!confirm("Are you sure you want to reset the entire diagram? All current data AND custom types will be lost and reset to defaults.")) return;
        console.log("Resetting diagram to defaults...");
        try {
            if(nodes) nodes.clear();
            if(edges) edges.clear();
            nodeGroupStyles = getInitialNodeGroupStyles();
            edgeTypeStyles = getInitialEdgeTypeStyles();
            nodeRoleStyles = getInitialNodeRoleStyles();
            nextNodeIdCounter = 1;
            edgeSpreadFactor = 0.35;

            editingNodeId = null; editingEdgeId = null; editingNodeGroupKeyMgmt = null; editingRelTypeIdMgmt = null; editingNodeRoleKeyMgmt = null;
            cancelEditNode(); cancelEditEdge(); cancelEditNodeGroupMgmt(); cancelEditRelTypeMgmt(); cancelEditNodeRoleMgmt();

            var newRelShowLabelCheckbox = document.getElementById('newRelShowLabel');
            var newRelLabelAlignDropdown = document.getElementById('newRelLabelAlign');
            if (newRelShowLabelCheckbox) newRelShowLabelCheckbox.checked = false;
            if (newRelLabelAlignDropdown) newRelLabelAlignDropdown.disabled = true;

            let cleanInitialOptions = getInitialVisNetworkOptions();
            visNetworkOptions = deepCopy(cleanInitialOptions);

            if(network) {
                network.setOptions(cleanInitialOptions);
                console.log("Network options reset.");
            } else { console.error("Network object not available during reset!"); }

            initializePhysicsControls();
            initializeAppearanceControls();

            populateNodeGroupDropdown(); populateEdgeTypeDropdown(); populateNodeRoleDropdown();
            renderAllListsAndLegends(); updateNodeSelectors();
            loadDefaultDataset();
            console.log("Diagram reset to defaults.");
            alert("Diagram has been reset.");
        } catch(e) {
            console.error("Error during diagram reset:", e);
            alert("An error occurred while resetting the diagram.");
        }
    }

    function handleSaveJsonData() {
        console.log("handleSaveJsonData called");
        try {
            var dataToSave = {
                fileHeader: { appName: "InteractiveVisMap", version: "2.0.0-sidebar", savedDateUTC: new Date().toISOString() }, // Version updated
                nextNodeIdCounter: nextNodeIdCounter,
                edgeSpreadFactor: edgeSpreadFactor,
                appearanceSettings: {
                    nodeSize: visNetworkOptions.nodes.size,
                    nodeFontSize: visNetworkOptions.nodes.font.size,
                    edgeBaseWidth: visNetworkOptions.edges.width,
                    edgeSmooth: deepCopy(visNetworkOptions.edges.smooth)
                },
                physicsSettings: deepCopy(visNetworkOptions.physics),
                nodeGroupStyles: nodeGroupStyles,
                edgeTypeStyles: edgeTypeStyles,
                nodeRoleStyles: nodeRoleStyles,
                nodes: nodes.get({ fields: ['id', 'label', 'group', 'role', 'shape', 'borderWidth', 'color', 'title', 'originalLabel', 'x', 'y'] }),
                edges: edges.get({ fields: ['id', 'from', 'to', 'label', 'font', 'color', 'arrows', 'smooth', 'width', 'strength', 'physics', 'visjs_edge_type_id'] })
            };
            var jsonData = JSON.stringify(dataToSave, null, 2);
            var blob = new Blob([jsonData], { type: 'application/json' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            var now = new Date();
            a.download = `vis_map_data_${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}.json`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
            console.log("JSON Data saved.");
        } catch (e) { console.error("Error saving JSON data:", e); alert("Error saving JSON. See console."); }
    }

    function handleLoadJsonFileSelect(event) { // This function now handles BOTH JSON and Text
        console.log("handleLoadJsonFileSelect or TextFileSelect called");
        var file = event.target.files[0];
        if (!file) return;

        if (file.type.match('application/json')) {
            var reader = new FileReader();
            reader.onload = function(e) {
                console.log("File loaded, parsing JSON...");
                try {
                    var loadedData = JSON.parse(e.target.result);
                    console.log("Parsed loaded data:", loadedData);
                    if (!loadedData || !loadedData.fileHeader || !loadedData.fileHeader.appName || loadedData.fileHeader.appName !== "InteractiveVisMap" || !loadedData.nodes || !loadedData.edges || !loadedData.nodeGroupStyles || !loadedData.edgeTypeStyles || !loadedData.nodeRoleStyles ) {
                        alert('Invalid/corrupted data file header or core data missing.');
                        console.error("Validation fail: Core structure.");
                        event.target.value = null; return;
                    }
                    if (!confirm("Loading JSON replaces current. OK?")) {
                        event.target.value = null; return;
                    }
                    nodes.clear(); edges.clear(); console.log("Cleared existing data.");
                    nextNodeIdCounter = loadedData.nextNodeIdCounter || Math.max(1, ...(loadedData.nodes || []).map(n => parseInt(String(n.id||"").replace('node_',''),10) || 0)) + 1 || 1;
                    edgeSpreadFactor = loadedData.edgeSpreadFactor || 0.35;

                    nodeGroupStyles = loadedData.nodeGroupStyles || getInitialNodeGroupStyles(); if(!nodeGroupStyles.general)nodeGroupStyles.general=getInitialNodeGroupStyles().general;
                    edgeTypeStyles = loadedData.edgeTypeStyles || getInitialEdgeTypeStyles();
                    nodeRoleStyles = loadedData.nodeRoleStyles || getInitialNodeRoleStyles();

                    const initialDefaults = getInitialVisNetworkOptions();
                    visNetworkOptions.physics = deepCopy(loadedData.physicsSettings || initialDefaults.physics);

                    const defaultAppearance = { nodeSize: initialDefaults.nodes.size, nodeFontSize: initialDefaults.nodes.font.size, edgeBaseWidth: initialDefaults.edges.width, edgeSmooth: deepCopy(initialDefaults.edges.smooth) };
                    const loadedAppearance = loadedData.appearanceSettings || defaultAppearance;

                    visNetworkOptions.nodes.size = loadedAppearance.nodeSize;
                    visNetworkOptions.nodes.font.size = loadedAppearance.nodeFontSize;
                    visNetworkOptions.edges.width = loadedAppearance.edgeBaseWidth;
                    visNetworkOptions.edges.smooth = deepCopy(loadedAppearance.edgeSmooth || initialDefaults.edges.smooth);

                    visNetworkOptions.groups = {};
                    Object.keys(nodeGroupStyles).forEach(k => { if(nodeGroupStyles.hasOwnProperty(k) && nodeGroupStyles[k] && nodeGroupStyles[k].color){ visNetworkOptions.groups[k] = { color: { background: nodeGroupStyles[k].color.background, border: nodeGroupStyles[k].color.border } }; }});

                    if(network){
                         let optionsToApply = {
                            physics: deepCopy(visNetworkOptions.physics),
                            nodes: { size: visNetworkOptions.nodes.size, font: { size: visNetworkOptions.nodes.font.size } },
                            edges: { width: visNetworkOptions.edges.width, smooth: deepCopy(visNetworkOptions.edges.smooth) },
                            groups: deepCopy(visNetworkOptions.groups)
                        };
                        network.setOptions(optionsToApply);
                        console.log("Network opts updated from JSON.");
                    } else {console.error("Network not initialized in LoadJSON!");}

                    initializePhysicsControls();
                    initializeAppearanceControls();

                    var nodesToLoad = (loadedData.nodes || []).map(n => { if (n.role && nodeRoleStyles[n.role]) { n.borderWidth = 3; n.color = n.color || {}; n.color.border = nodeRoleStyles[n.role].color; n.shape = nodeRoleStyles[n.role].shape || 'circle'; } else { n.role = 'ic'; const defaultRole = nodeRoleStyles['ic'] || { color: '#CCCCCC', shape: 'circle' }; n.borderWidth = 3; n.color = n.color || {}; n.color.border = defaultRole.color; n.shape = defaultRole.shape; } if (!n.group || !nodeGroupStyles[n.group]) n.group = 'general'; if (n.color && n.color.background) delete n.color.background; return n; });
                    if (nodesToLoad.length > 0) nodes.add(nodesToLoad);

                    var edgesToLoad = (loadedData.edges || []).map(e => { e.strength = e.strength || 'medium'; e.width = getEdgeWidthFromStrength(e.strength); if (!e.physics || typeof e.physics.length !== 'number') { e.physics = { length: undefined }; }
                        e.smooth = e.smooth || visNetworkOptions.edges.smooth;
                        return e;
                    });
                    if (edgesToLoad.length > 0) edges.add(edgesToLoad);

                    console.log("Loaded data to DataSets.");
                    setTimeout(function(){ console.log("Attempting UI refresh post-JSON load."); try{populateNodeGroupDropdown();populateEdgeTypeDropdown();populateNodeRoleDropdown();renderAllListsAndLegends();updateNodeSelectors();reapplySmoothToAllEdges();console.log("UI refreshed post-JSON load.");alert('JSON Data loaded!')}catch(uiError){console.error("Err UI refresh post-JSON:",uiError);alert("Data loaded, UI refresh issue.")}},50);
                } catch (parseError) {
                    console.error("Err parsing JSON:",parseError);
                    alert('Error parsing JSON file.');
                } finally {
                    event.target.value = null;
                    console.log("JSON File input reset.");
                }
            };
            reader.onerror = function(){
                console.error("FileReader err (JSON):",reader.error);
                alert("Err reading file.");
                event.target.value=null;
            };
            reader.readAsText(file);
        } else if (file.type.match('text/plain') || file.name.endsWith('.txt')) {
            var reader = new FileReader();
            reader.onload = function(e) {
                console.log("Text file loaded, processing...");
                try {
                    if (!confirm("Loading Text Data will replace the current diagram with basic node/edge information. Advanced settings and types will NOT be loaded. OK?")) {
                        event.target.value = null; return;
                    }
                    processLoadedTextData(e.target.result);
                } catch (err) {
                    console.error("Error processing text file:", err);
                    alert("Error processing text file. See console.");
                } finally {
                    event.target.value = null;
                }
            };
            reader.onerror = function() {
                console.error("FileReader error (Text):", reader.error);
                alert("Error reading text file.");
                event.target.value = null;
            };
            reader.readAsText(file);
        } else {
            alert('Invalid file type. Please select a JSON (.json) or Text (.txt) file.');
            event.target.value = null;
            return;
        }
    }

    function handleSaveTextData() {
        console.log("handleSaveTextData called");
        try {
            let textContent = "APP_VERSION: InteractiveVisMap_Text_1.0.1\n";
            textContent += "NOTE: This format saves basic node, edge, and type definition data. For full fidelity (positions, physics, appearance), use JSON save.\n\n";

            textContent += "NODES\n";
            textContent += "id,originalLabel,groupKey,roleKey\n";
            nodes.get({ fields: ['id', 'originalLabel', 'label', 'group', 'role'] }).forEach(node => { // Added label as fallback
                textContent += `${node.id},${node.originalLabel || node.label.replace(/\n/g,' ')},${node.group},${node.role}\n`;
            });

            textContent += "\nEDGES\n";
            textContent += "fromNodeId,toNodeId,edgeTypeId,strength\n";
            edges.get({ fields: ['from', 'to', 'visjs_edge_type_id', 'strength'] }).forEach(edge => {
                textContent += `${edge.from},${edge.to},${edge.visjs_edge_type_id || 'unknown'},${edge.strength || 'medium'}\n`;
            });

            textContent += "\nNODE_GROUPS\n";
            textContent += "key,name,colorHex\n";
            Object.keys(nodeGroupStyles).forEach(key => {
                 const group = nodeGroupStyles[key];
                 textContent += `${key},${group.name},${group.color.background}\n`;
            });

            textContent += "\nNODE_ROLES\n";
            textContent += "key,name,colorHex,shape\n";
            Object.keys(nodeRoleStyles).forEach(key => {
                 const role = nodeRoleStyles[key];
                 textContent += `${key},${role.name},${role.color},${role.shape}\n`;
            });

            textContent += "\nRELATIONSHIP_TYPES\n";
            textContent += "id,label,colorHex,arrowStyle,showLabelOnDiagram,labelAlign\n";
            edgeTypeStyles.forEach(type => {
                 textContent += `${type.id},${type.label},${type.color},${type.arrowStyle},${type.showLabelOnDiagram !== false},${type.labelAlign || 'middle'}\n`;
            });

            var blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            var now = new Date();
            a.download = `vis_map_data_${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            console.log("Text Data saved.");
            alert("Basic text data saved. Note: This format is limited compared to JSON.");
        } catch (e) {
            console.error("Error saving Text data:", e);
            alert("Error saving Text data. See console.");
        }
    }

    function processLoadedTextData(text) {
        console.log("Processing loaded text data...");
        try {
            nodes.clear();
            edges.clear();

            // Temporarily store loaded definitions to avoid conflicts if they are used before full parse
            let loadedNodeGroups = {};
            let loadedNodeRoles = {};
            let loadedEdgeTypes = [];

            const lines = text.split('\n');
            let mode = null;
            let tempNodeIdCounter = 1;

            lines.forEach(line => {
                line = line.trim();
                if (line.startsWith("APP_VERSION:") || line.startsWith("NOTE:") || line === "") return;

                if (line === "NODES") { mode = "NODES"; return; }
                if (line === "EDGES") { mode = "EDGES"; return; }
                if (line === "NODE_GROUPS") { mode = "NODE_GROUPS"; return;}
                if (line === "NODE_ROLES") { mode = "NODE_ROLES"; return;}
                if (line === "RELATIONSHIP_TYPES") {mode = "RELATIONSHIP_TYPES"; return;}

                if (mode === "NODE_GROUPS") {
                    if (line.startsWith("key,name,colorHex")) return;
                    const parts = line.split(',');
                    if (parts.length >= 3) {
                        const key = parts[0];
                        loadedNodeGroups[key] = {
                            name: parts[1],
                            color: { background: parts[2], border: darkenColor(parts[2], 30) },
                            isDeletable: (key !== 'general' && key !== (getInitialNodeGroupStyles().leadership ? Object.keys(getInitialNodeGroupStyles()).find(k => getInitialNodeGroupStyles()[k].name === 'Leadership') : 'leadership') )
                        };
                    }
                } else if (mode === "NODE_ROLES") {
                    if (line.startsWith("key,name,colorHex,shape")) return;
                     const parts = line.split(',');
                    if (parts.length >= 4) {
                        const key = parts[0];
                        loadedNodeRoles[key] = {
                            name: parts[1],
                            color: parts[2],
                            shape: parts[3],
                            isDeletable: (key !== 'ic')
                        };
                    }
                } else if (mode === "RELATIONSHIP_TYPES") {
                     if (line.startsWith("id,label,colorHex,arrowStyle,showLabelOnDiagram,labelAlign")) return;
                     const parts = line.split(',');
                     if (parts.length >= 6) {
                        const typeData = {
                            id: parts[0], label: parts[1], color: parts[2], arrowStyle: parts[3],
                            showLabelOnDiagram: parts[4] === 'true', labelAlign: parts[5],
                            isDeletable: !Object.values(getInitialEdgeTypeStyles()).find(it => it.id === parts[0] && it.isDeletable === false)
                        };
                        loadedEdgeTypes.push(typeData);
                    }
                }
            });

            // Apply loaded definitions
            if(Object.keys(loadedNodeGroups).length > 0) nodeGroupStyles = loadedNodeGroups; else nodeGroupStyles = getInitialNodeGroupStyles();
            if(Object.keys(loadedNodeRoles).length > 0) nodeRoleStyles = loadedNodeRoles; else nodeRoleStyles = getInitialNodeRoleStyles();
            if(loadedEdgeTypes.length > 0) edgeTypeStyles = loadedEdgeTypes; else edgeTypeStyles = getInitialEdgeTypeStyles();


            lines.forEach(line => { // Second pass for Nodes and Edges
                line = line.trim();
                if (line.startsWith("APP_VERSION:") || line.startsWith("NOTE:") || line === "") return;
                if (line === "NODES") { mode = "NODES"; return; } // Set mode again
                if (line === "EDGES") { mode = "EDGES"; return; } // Set mode again
                if (line === "NODE_GROUPS" || line === "NODE_ROLES" || line === "RELATIONSHIP_TYPES") {mode = null; return;}


                if (mode === "NODES") {
                    if (line.startsWith("id,originalLabel")) return;
                    const parts = line.split(',');
                    if (parts.length >= 4) {
                        const nodeId = parts[0];
                        if (nodeId.startsWith('node_')) {
                            const numPart = parseInt(nodeId.substring(5), 10);
                            if (!isNaN(numPart) && numPart >= tempNodeIdCounter) {
                                tempNodeIdCounter = numPart + 1;
                            }
                        }
                        addNodeInternal(parts[1], parts[2], parts[3], nodeId);
                    }
                } else if (mode === "EDGES") {
                    if (line.startsWith("fromNodeId,toNodeId")) return;
                    const parts = line.split(',');
                    if (parts.length >= 4) {
                        const edgeTypeInfo = edgeTypeStyles.find(et => et.id === parts[2]);
                        let arrowFrom = false; let arrowTo = false; let showLabel = false;
                        if (edgeTypeInfo) {
                            arrowFrom = (edgeTypeInfo.arrowStyle === 'bi' || edgeTypeInfo.arrowStyle === 'from');
                            arrowTo = (edgeTypeInfo.arrowStyle === 'bi' || edgeTypeInfo.arrowStyle === 'to');
                            showLabel = edgeTypeInfo.showLabelOnDiagram !== false;
                        }
                        addEdgeInternal(parts[0], parts[1], parts[2], arrowFrom, arrowTo, parts[3], showLabel);
                    }
                }
            });

            nextNodeIdCounter = Math.max(nextNodeIdCounter, tempNodeIdCounter);

            populateNodeGroupDropdown(); populateNodeRoleDropdown(); populateEdgeTypeDropdown();
            renderAllListsAndLegends(); updateNodeSelectors(); reapplySmoothToAllEdges();

            alert("Basic text data loaded. Some settings (positions, physics, detailed appearance) are not included in text format.");
        } catch (e) {
            console.error("Error processing loaded text data:", e);
            alert("Error processing text data. Check format or see console.");
        }
    }


    function handleEdgeSpreadChange(event) {
        var input = event.target;
        var newFactor = parseFloat(input.value);
        if (!isNaN(newFactor) && newFactor >= 0 && newFactor <= 1) {
            if (edgeSpreadFactor !== newFactor) {
                edgeSpreadFactor = newFactor;
                console.log("Edge Spread Factor (for parallel edges) variable updated to:", edgeSpreadFactor);
                 reapplySmoothToAllEdges();
            }
        } else {
            alert("Invalid spread factor (must be 0-1).");
            input.value = edgeSpreadFactor;
        }
    }

    function applyPhysicsChanges() {
        if (!network) { console.error("ApplyPhysics: Network not ready."); return; }
        console.log("Applying physics changes...");
        try {
            const toggle = document.getElementById('physicsEnabledToggle');
            if (!toggle) { console.error("Physics toggle not found."); return; }
            const physicsEnabled = toggle.checked;
            let newPhysicsConfig;

            if (physicsEnabled) {
                newPhysicsConfig = {
                    enabled: true,
                    solver: 'barnesHut',
                    barnesHut: {
                        springConstant: parseFloat(document.getElementById('physicsSpringConstantInput').value),
                        centralGravity: parseFloat(document.getElementById('physicsGravityInput').value),
                        gravitationalConstant: parseFloat(document.getElementById('physicsRepulsionInput').value),
                        springLength: parseFloat(document.getElementById('physicsSpringLengthInput').value),
                        damping: parseFloat(document.getElementById('physicsDampingInput').value)
                    }
                };
                if (Object.values(newPhysicsConfig.barnesHut).some(isNaN)) {
                    alert("Invalid physics value detected. Please check inputs."); return;
                }
            } else {
                newPhysicsConfig = { enabled: false };
            }

            visNetworkOptions.physics = deepCopy(newPhysicsConfig);
            network.setOptions({ physics: newPhysicsConfig });
            console.log("Physics options updated in network. Enabled: " + physicsEnabled);

            if (physicsEnabled && network.physics.options.enabled) {
                 network.setOptions({ physics: { enabled: false }});
                 setTimeout(() => {
                    network.setOptions({ physics: { enabled: true }});
                    console.log("Physics simulation restarted.");
                }, 50);
            }
            togglePhysicsInputsActiveState();
            alert("Physics settings applied.");
        } catch (e) { console.error("Error applying physics changes:", e); alert("Error applying physics settings."); initializePhysicsControls(); }
    }

     function applyAppearanceChanges() {
        if (!network) { console.error("ApplyAppearance: Network not ready."); return; }
        console.log("Applying appearance changes...");
        try {
             const spreadFactorEl = document.getElementById('edgeSpreadFactorInput');
             const smoothTypeEl = document.getElementById('edgeSmoothTypeInput');
             const smoothRoundnessEl = document.getElementById('edgeSmoothRoundnessInput');
             const nodeSizeEl = document.getElementById('appearanceNodeSizeInput');
             const nodeFontSizeEl = document.getElementById('appearanceNodeFontSizeInput');
             const edgeWidthEl = document.getElementById('appearanceEdgeBaseWidthInput');

             // Check if elements exist before accessing value
             const newSpreadFactor = spreadFactorEl ? parseFloat(spreadFactorEl.value) : edgeSpreadFactor;
             const newSmoothType = smoothTypeEl ? smoothTypeEl.value : visNetworkOptions.edges.smooth.type;
             const newSmoothRoundness = smoothRoundnessEl ? parseFloat(smoothRoundnessEl.value) : visNetworkOptions.edges.smooth.roundness;
             const newNodeSize = nodeSizeEl ? parseInt(nodeSizeEl.value, 10) : visNetworkOptions.nodes.size;
             const newNodeFontSize = nodeFontSizeEl ? parseInt(nodeFontSizeEl.value, 10) : visNetworkOptions.nodes.font.size;
             const newEdgeBaseWidth = edgeWidthEl ? parseFloat(edgeWidthEl.value) : visNetworkOptions.edges.width;


             let isValid = true; let errorMsg = "Invalid input detected:\n";
             if (isNaN(newSpreadFactor) || newSpreadFactor < 0 || newSpreadFactor > 1) { isValid = false; errorMsg += "- Edge Curve Factor (Parallel) must be 0-1\n"; if(spreadFactorEl) spreadFactorEl.value = edgeSpreadFactor; }
             if (isNaN(newSmoothRoundness) && ['curvedCW', 'curvedCCW', 'cubicBezier'].includes(newSmoothType)) { isValid = false; errorMsg += "- Edge Smooth Roundness is invalid.\n"; if(smoothRoundnessEl) smoothRoundnessEl.value = visNetworkOptions.edges.smooth.roundness; }
             if (isNaN(newNodeSize) || newNodeSize < 1) { isValid = false; errorMsg += "- Node Size must be >= 1\n"; if(nodeSizeEl) nodeSizeEl.value = visNetworkOptions.nodes.size; }
             if (isNaN(newNodeFontSize) || newNodeFontSize < 6) { isValid = false; errorMsg += "- Node Font Size must be >= 6\n"; if(nodeFontSizeEl) nodeFontSizeEl.value = visNetworkOptions.nodes.font.size; }
             if (isNaN(newEdgeBaseWidth) || newEdgeBaseWidth < 0.5) { isValid = false; errorMsg += "- Edge Base Width must be >= 0.5\n"; if(edgeWidthEl) edgeWidthEl.value = visNetworkOptions.edges.width; }
             if (!isValid) { alert(errorMsg); return; }

             edgeSpreadFactor = newSpreadFactor;
             visNetworkOptions.nodes.size = newNodeSize;
             visNetworkOptions.nodes.font.size = newNodeFontSize;
             visNetworkOptions.edges.width = newEdgeBaseWidth;
             visNetworkOptions.edges.smooth.type = newSmoothType;
             if (['curvedCW', 'curvedCCW', 'cubicBezier'].includes(newSmoothType)) {
                 visNetworkOptions.edges.smooth.roundness = newSmoothRoundness;
             } else {
                 delete visNetworkOptions.edges.smooth.roundness;
             }
             visNetworkOptions.edges.smooth.enabled = visNetworkOptions.edges.smooth.enabled !== false;


             network.setOptions({
                 nodes: { size: newNodeSize, font: { size: newNodeFontSize } },
                 edges: {
                     width: newEdgeBaseWidth,
                     smooth: deepCopy(visNetworkOptions.edges.smooth)
                 }
             });
             console.log("Base appearance options set on network.");

             const edgeUpdates = [];
             edges.get().forEach(edge => {
                 const newWidth = getEdgeWidthFromStrength(edge.strength || 'medium');
                 if (edge.width !== newWidth) { edgeUpdates.push({ id: edge.id, width: newWidth }); }
             });
             if (edgeUpdates.length > 0) { edges.update(edgeUpdates); console.log(`Recalculated and updated width for ${edgeUpdates.length} edges.`); }

             reapplySmoothToAllEdges();
             console.log("Appearance options updated successfully.");
             alert("Appearance settings applied.");
         } catch (e) { console.error("Error applying appearance changes:", e); alert("Error applying appearance settings."); initializeAppearanceControls(); }
     }

    function reapplySmoothToParallelEdges(nodeId1, nodeId2) {
        if (!nodeId1 || !nodeId2 || !edges || typeof edges.get !== 'function' || !nodes || typeof nodes.get !== 'function') { return; }
        if (!nodes.get(String(nodeId1)) || !nodes.get(String(nodeId2))) { return; }

        const n1Str = String(nodeId1);
        const n2Str = String(nodeId2);
        const allEdgesBetweenNodes = edges.get({
            filter: item => (String(item.from) === n1Str && String(item.to) === n2Str) || (String(item.from) === n2Str && String(item.to) === n1Str)
        }).sort((a, b) => String(a.id).localeCompare(String(b.id)));

        let updates = [];
        const numEdges = allEdgesBetweenNodes.length;

        if (numEdges === 0) {
            return;
        } else if (numEdges === 1) {
            const edge = allEdgesBetweenNodes[0];
            const singleEdgeSmoothOpt = deepCopy(visNetworkOptions.edges.smooth) || { enabled: true, type: "dynamic", roundness: 0.5 };
            if (singleEdgeSmoothOpt.enabled === undefined) singleEdgeSmoothOpt.enabled = true;

            if (JSON.stringify(edge.smooth) !== JSON.stringify(singleEdgeSmoothOpt)) {
                 updates.push({ id: edge.id, smooth: singleEdgeSmoothOpt });
            }
        } else {
            const maxRoundness = 0.85;
            allEdgesBetweenNodes.forEach((edge, index) => {
                let smoothOpt;
                const pairIndex = Math.floor(index / 2);
                let currentRoundness = (pairIndex === 0) ? edgeSpreadFactor : Math.min(maxRoundness, edgeSpreadFactor + pairIndex * (edgeSpreadFactor * 0.75));
                currentRoundness = Math.max(0.05, currentRoundness);

                if (index % 2 === 0) {
                    smoothOpt = { enabled: true, type: 'curvedCW', roundness: currentRoundness, forceDirection: 'none' };
                } else {
                    smoothOpt = { enabled: true, type: 'curvedCCW', roundness: currentRoundness, forceDirection: 'none' };
                }

                if (JSON.stringify(edge.smooth) !== JSON.stringify(smoothOpt)) {
                    updates.push({ id: edge.id, smooth: smoothOpt });
                }
            });
        }

        if (updates.length > 0) {
            try {
                edges.update(updates);
                console.log("Applied smooth updates for", nodeId1, "-", nodeId2, ":", updates.length);
            } catch (e) {
                console.error("Error updating edge smoothness:", e, updates);
            }
        }
    }

    function reapplySmoothToAllEdges() { console.log("Attempting to reapply smooth to ALL edges based on global smooth settings and parallel factor:", edgeSpreadFactor); if (!edges || typeof edges.get !== 'function') { console.error("reapplySmooth: Edges dataset not ready."); return; } const uniquePairs = new Set(); try { edges.get().forEach(edge => { if(edge.from && edge.to) { const pair = [edge.from, edge.to].sort().join('-'); uniquePairs.add(pair); } }); uniquePairs.forEach(pairStr => { const [nodeId1, nodeId2] = pairStr.split('-'); reapplySmoothToParallelEdges(nodeId1, nodeId2); }); console.log("Re-applied smooth to all relevant edge pairs."); } catch (e) { console.error("Error in reapplySmoothToAllEdges:", e); } }


    // --- Node Instance Management ---
    function handleSaveNode() { var labelInput = document.getElementById('nodeLabel'); var groupSelect = document.getElementById('nodeGroup'); var roleSelect = document.getElementById('nodeRole'); var originalLabel = labelInput.value.trim(); var groupKey = groupSelect.value; var roleKey = roleSelect.value; if (!originalLabel || !groupKey || !roleKey) { alert('Name, Group, and Role are required.'); return; } var visNodeLabel = originalLabel.replace(/ /g, '\n'); var groupInfo = nodeGroupStyles[groupKey] || nodeGroupStyles['general']; var roleInfo = nodeRoleStyles[roleKey] || nodeRoleStyles['ic']; var nodeTitle = originalLabel + ` (Dept: ${groupInfo.name}, Role: ${roleInfo.name})`; if (!visNetworkOptions.groups[groupKey]) { console.warn(`Group ${groupKey} not in network options, adding.`); visNetworkOptions.groups[groupKey] = { color: { background: groupInfo.color.background, border: groupInfo.color.border } }; if(network) network.setOptions({ groups: deepCopy(visNetworkOptions.groups) }); } var nodeDataItem = { label: visNodeLabel, group: groupKey, role: roleKey, title: nodeTitle, originalLabel: originalLabel, shape: roleInfo.shape || 'circle', borderWidth: 3, color: { border: roleInfo.color } }; console.log("Saving node:", JSON.parse(JSON.stringify(nodeDataItem)), "Group:", groupKey); if (editingNodeId) { nodeDataItem.id = editingNodeId; nodes.update(nodeDataItem); console.log('Node updated:', editingNodeId); } else { var existing = nodes.get({ filter: i => i.originalLabel === originalLabel }); if (existing.length > 0 && !confirm(`Node "${originalLabel}" exists. Add anyway?`)) return; nodeDataItem.id = 'node_' + (nextNodeIdCounter++); nodes.add(nodeDataItem); console.log('Node added:', nodeDataItem.id); } renderNodeList(); updateNodeSelectors(); cancelEditNode(); }
    function prepareEditNode(nodeId){ var n=nodes.get(nodeId);if(!n)return;editingNodeId=nodeId;document.getElementById('nodeLabel').value=n.originalLabel||n.label.replace(/\n/g,' ');document.getElementById('nodeGroup').value=n.group||'general'; document.getElementById('nodeRole').value = n.role || 'ic'; document.getElementById('nodeFormTitle').textContent='Edit Person';document.getElementById('btnSaveNode').textContent='Update';document.getElementById('btnSaveNode').classList.add('update-btn');document.getElementById('btnCancelEditNode').classList.remove('hidden'); /* Switch to edit tab if needed */ activateTab('tab-edit'); document.getElementById('nodeLabel').focus();}
    function cancelEditNode(){ editingNodeId=null;document.getElementById('nodeLabel').value='';document.getElementById('nodeGroup').value='general'; document.getElementById('nodeRole').value='ic'; document.getElementById('nodeFormTitle').textContent='Add/Edit Person';document.getElementById('btnSaveNode').textContent='Add Person';document.getElementById('btnSaveNode').classList.remove('update-btn');document.getElementById('btnCancelEditNode').classList.add('hidden')}
    function deleteNode(nodeId){ if(!confirm("Delete person & associated relationships?"))return;try{var cE=edges.get({filter:e=>e.from===nodeId||e.to===nodeId}).map(e=>e.id);if(cE.length>0)edges.remove(cE);nodes.remove(nodeId);renderNodeList();renderEdgeList();updateNodeSelectors();setTimeout(reapplySmoothToAllEdges,100)}catch(e){console.error('Err del node:',nodeId,e)}}


    // --- Edge Instance Management ---
    function handleSaveEdge() { var fromNodeId=document.getElementById('edgeFrom').value, toNodeId=document.getElementById('edgeTo').value; var edgeTypeId=document.getElementById('edgeType').value; var edgeStrength = document.getElementById('edgeStrength').value; var overrideArrowFrom = document.getElementById('overrideArrowFrom').checked; var overrideArrowTo = document.getElementById('overrideArrowTo').checked; var overrideShowLabel = document.getElementById('overrideShowLabel').checked; if(!fromNodeId||!toNodeId){alert('Select From/To persons.');return} if(fromNodeId===toNodeId&&!editingEdgeId){alert('Cannot create relationship from/to the same person.');return} if(!edgeTypeId){alert('Select Relationship Type.');return} var type=edgeTypeStyles.find(t=>t.id===edgeTypeId); if(!type){alert('Relationship type definition missing.');return} var edgeArrows = {}; if (overrideArrowFrom) edgeArrows.from = { enabled: true, type: 'arrow' }; if (overrideArrowTo) edgeArrows.to = { enabled: true, type: 'arrow' }; if (!overrideArrowFrom && !overrideArrowTo) { edgeArrows = mapArrowStyleToVisOptions(type.arrowStyle); } var finalLabel = overrideShowLabel ? type.label : undefined; var finalFontAlign = overrideShowLabel ? (type.labelAlign || 'middle') : undefined; var edgeData={ label: finalLabel, font: { size: 10, align: finalFontAlign }, color: { color: type.color }, arrows: edgeArrows, visjs_edge_type_id: type.id, strength: edgeStrength, width: getEdgeWidthFromStrength(edgeStrength), physics: { length: getEdgeLengthFromStrength(edgeStrength) } }; var fromForSmooth = fromNodeId, toForSmooth = toNodeId; if(editingEdgeId){ edgeData.id=editingEdgeId;var cE=edges.get(editingEdgeId);if(!cE){cancelEditEdge();return} edgeData.from=cE.from; edgeData.to=cE.to; fromForSmooth = cE.from; toForSmooth = cE.to; try{edges.update(edgeData); console.log("Edge updated:",editingEdgeId)}catch(e){console.error("Err updating edge:",e)} }else{ edgeData.from=fromNodeId;edgeData.to=toNodeId; var ex=edges.get({filter:e=>(e.from===fromNodeId&&e.to===toNodeId&&e.visjs_edge_type_id===type.id) || (e.from===toNodeId&&e.to===fromNodeId&&e.visjs_edge_type_id===type.id && type.arrowStyle !== 'to' && type.arrowStyle !== 'from')}); if(ex.length>0){alert("Similar relationship already exists.");return} try{edges.add(edgeData); console.log("Edge added")}catch(e){console.error("Err adding edge:",e)} } reapplySmoothToParallelEdges(fromForSmooth,toForSmooth); renderEdgeList();cancelEditEdge(); }
    function prepareEditEdge(edgeId){ var e=edges.get(edgeId);if(!e){console.error("Edge not found for edit:",edgeId);return}editingEdgeId=edgeId; console.log("Prep edit edge:",e);document.getElementById('edgeFrom').value=e.from;document.getElementById('edgeTo').value=e.to;document.getElementById('edgeFrom').disabled=true;document.getElementById('edgeTo').disabled=true;document.getElementById('edgeType').value=e.visjs_edge_type_id||'';document.getElementById('edgeStrength').value = e.strength || 'medium'; var arrowFromCheckbox = document.getElementById('overrideArrowFrom'); var arrowToCheckbox = document.getElementById('overrideArrowTo'); var showLabelCheckbox = document.getElementById('overrideShowLabel'); if(e.arrows && e.arrows.from && e.arrows.from.enabled) arrowFromCheckbox.checked = true; else arrowFromCheckbox.checked = false; if(e.arrows && e.arrows.to && e.arrows.to.enabled) arrowToCheckbox.checked = true; else arrowToCheckbox.checked = false; showLabelCheckbox.checked = (e.label !== undefined && e.label !== null); if(!document.getElementById('edgeType').value&&edgeTypeStyles.length>0){let ft=edgeTypeStyles.find(et=>et.label===e.label);if(ft)document.getElementById('edgeType').value=ft.id}document.getElementById('edgeFormTitle').textContent='Edit Relationship';document.getElementById('btnSaveEdge').textContent='Update Relationship';document.getElementById('btnSaveEdge').classList.add('update-btn');document.getElementById('btnCancelEditEdge').classList.remove('hidden'); /* Switch to edit tab if needed */ activateTab('tab-edit'); document.getElementById('edgeType').focus();}
    function cancelEditEdge(){ editingEdgeId=null;document.getElementById('edgeFrom').value='';document.getElementById('edgeTo').value='';document.getElementById('edgeFrom').disabled=false;document.getElementById('edgeTo').disabled=false;if(edgeTypeStyles.length>0)document.getElementById('edgeType').value=edgeTypeStyles[0].id;else document.getElementById('edgeType').value='';document.getElementById('edgeStrength').value = 'medium'; document.getElementById('overrideArrowFrom').checked = false; document.getElementById('overrideArrowTo').checked = false; document.getElementById('overrideShowLabel').checked = false; document.getElementById('edgeFormTitle').textContent='Add/Edit Relationship';document.getElementById('btnSaveEdge').textContent='Add Relationship';document.getElementById('btnSaveEdge').classList.remove('update-btn');document.getElementById('btnCancelEditEdge').classList.add('hidden'); updateEdgeOverridesFromType(); console.log("Edge edit cancelled.")}
    function deleteEdge(edgeId){ if(!confirm("Delete relationship?"))return;try{var e=edges.get(edgeId);if(e){var fNId=e.from,tNId=e.to;edges.remove(edgeId);console.log("Edge removed:",edgeId);reapplySmoothToParallelEdges(fNId,tNId);renderEdgeList()}}catch(err){console.error('Err del edge:',edgeId,err)}}
    function updateEdgeOverridesFromType() { var edgeTypeDropdown = document.getElementById('edgeType'); var selectedTypeId = edgeTypeDropdown ? edgeTypeDropdown.value : null; if (!selectedTypeId) return; var typeInfo = edgeTypeStyles.find(t => t.id === selectedTypeId); var arrowFromCheckbox = document.getElementById('overrideArrowFrom'); var arrowToCheckbox = document.getElementById('overrideArrowTo'); var showLabelCheckbox = document.getElementById('overrideShowLabel'); if (!arrowFromCheckbox || !arrowToCheckbox || !showLabelCheckbox) return; if (typeInfo) { arrowFromCheckbox.checked = (typeInfo.arrowStyle === 'bi' || typeInfo.arrowStyle === 'from'); arrowToCheckbox.checked = (typeInfo.arrowStyle === 'bi' || typeInfo.arrowStyle === 'to'); showLabelCheckbox.checked = (typeInfo.showLabelOnDiagram !== false); } else { arrowFromCheckbox.checked = false; arrowToCheckbox.checked = false; showLabelCheckbox.checked = false; } }


    // --- Node Group Definition Management ---
     function handleSaveNodeGroupMgmt(){var nI=document.getElementById('newGroupName'),cI=document.getElementById('newGroupColor');var name=nI.value.trim(),clr=cI.value;if(!name){alert('Group Name req.');return}var key=editingNodeGroupKeyMgmt;if(!key){key=sanitizeKey(name);if(!key){alert('Invalid Name.');return}if(nodeGroupStyles[key]){alert(`Group key "${key}" exists.`);return}nodeGroupStyles[key]={name:name,color:{},isDeletable:true}}nodeGroupStyles[key].name=name;nodeGroupStyles[key].color={background:clr,border:darkenColor(clr,30)};nodeGroupStyles[key].isDeletable = nodeGroupStyles[key].isDeletable !== false;
         visNetworkOptions.groups[key] = { color: { background: nodeGroupStyles[key].color.background, border: nodeGroupStyles[key].color.border } };
         if(network) network.setOptions({ groups: deepCopy(visNetworkOptions.groups) });
         console.log(`Updated group definition and applied to network for key ${key}`);
         if(editingNodeGroupKeyMgmt){ var nodesTT=[]; nodes.get().forEach(n=>{ if(n.group===editingNodeGroupKeyMgmt){ var roleInfo = nodeRoleStyles[n.role] || nodeRoleStyles['ic']; nodesTT.push({id:n.id, group: key, title:(n.originalLabel||n.label.replace(/\n/g,' '))+' (Dept: '+name+', Role: '+roleInfo.name+')'}); }}); if(nodesTT.length>0) nodes.update(nodesTT); }
         renderAllListsAndLegends();populateNodeGroupDropdown();cancelEditNodeGroupMgmt(); }
    function prepareEditNodeGroupMgmt(key){var g=nodeGroupStyles[key];if(!g)return;editingNodeGroupKeyMgmt=key;document.getElementById('newGroupName').value=g.name;document.getElementById('newGroupColor').value=g.color.background; document.getElementById('nodeGroupFormTitleMgmt').textContent='Edit Group Type';document.getElementById('btnSaveNodeGroupMgmt').textContent='Update Group Type'; document.getElementById('btnSaveNodeGroupMgmt').classList.add('update-btn');document.getElementById('btnCancelEditNodeGroupMgmt').classList.remove('hidden'); /* Switch to define tab */ activateTab('tab-define'); document.getElementById('newGroupName').focus();}
    function cancelEditNodeGroupMgmt(){editingNodeGroupKeyMgmt=null;document.getElementById('newGroupName').value='';document.getElementById('newGroupColor').value='#e0e0e0'; document.getElementById('nodeGroupFormTitleMgmt').textContent='New/Edit Group Type';document.getElementById('btnSaveNodeGroupMgmt').textContent='Add Group Type'; document.getElementById('btnSaveNodeGroupMgmt').classList.remove('update-btn');document.getElementById('btnCancelEditNodeGroupMgmt').classList.add('hidden');}
    function handleDeleteNodeGroupMgmt(key){if(!nodeGroupStyles[key]||nodeGroupStyles[key].isDeletable===false){alert(key==='general'?'Cannot delete General group.':'This group cannot be deleted.');return}if(!confirm(`Del group "${nodeGroupStyles[key].name}"? Nodes move to General.`))return; try{delete nodeGroupStyles[key]; delete visNetworkOptions.groups[key];
        if(network)network.setOptions({groups: deepCopy(visNetworkOptions.groups)});
        var nU=[];nodes.get().forEach(n=>{if(n.group===key){var roleInfo = nodeRoleStyles[n.role] || nodeRoleStyles['ic']; nU.push({id:n.id,group:'general',title:(n.originalLabel||n.label.replace(/\n/g,' '))+' (Dept: '+nodeGroupStyles['general'].name+', Role: '+roleInfo.name+')'})}});if(nU.length>0)nodes.update(nU); renderAllListsAndLegends();populateNodeGroupDropdown();if(editingNodeGroupKeyMgmt===key)cancelEditNodeGroupMgmt(); }catch(e){console.error("Err del node group def:",key,e)}}


    // --- Node Role Definition Management ---
     function handleSaveNodeRoleMgmt() { var nameInput = document.getElementById('newNodeRoleName'); var colorInput = document.getElementById('newNodeRoleColor'); var shapeInput = document.getElementById('newNodeRoleShape'); var roleName = nameInput.value.trim(); var roleColor = colorInput.value; var roleShape = shapeInput.value; if (!roleName) { alert('Role Name is required.'); return; } var roleKey = editingNodeRoleKeyMgmt; if (!roleKey) { roleKey = sanitizeKey(roleName); if (!roleKey) { alert('Invalid Role Name (produces empty key).'); return; } if (nodeRoleStyles[roleKey]) { alert(`Role key "${roleKey}" already exists.`); return; } nodeRoleStyles[roleKey] = { name: roleName, color: roleColor, shape: roleShape, isDeletable: true }; } else { if (nodeRoleStyles[roleKey]) { nodeRoleStyles[roleKey].name = roleName; nodeRoleStyles[roleKey].color = roleColor; nodeRoleStyles[roleKey].shape = roleShape; nodeRoleStyles[roleKey].isDeletable = nodeRoleStyles[roleKey].isDeletable !== false; var nodesToUpdate = []; nodes.get().forEach(node => { if (node.role === roleKey) { var groupInfo = nodeGroupStyles[node.group] || nodeGroupStyles['general']; nodesToUpdate.push({ id: node.id, shape: roleShape, color: { border: roleColor }, title: (node.originalLabel || node.label.replace(/\n/g, ' ')) + ` (Dept: ${groupInfo.name}, Role: ${roleName})` }); } }); if (nodesToUpdate.length > 0) nodes.update(nodesToUpdate); } else { console.error("Editing role key not found:", roleKey); } } renderAllListsAndLegends(); populateNodeRoleDropdown(); cancelEditNodeRoleMgmt(); }
    function prepareEditNodeRoleMgmt(roleKey) { var role = nodeRoleStyles[roleKey]; if (!role) { console.error("Role not found for edit:", roleKey); return; } editingNodeRoleKeyMgmt = roleKey; document.getElementById('newNodeRoleName').value = role.name; document.getElementById('newNodeRoleColor').value = role.color; document.getElementById('newNodeRoleShape').value = role.shape || 'circle'; document.getElementById('nodeRoleFormTitleMgmt').textContent = 'Edit Role Type'; document.getElementById('btnSaveNodeRoleMgmt').textContent = 'Update Role Type'; document.getElementById('btnSaveNodeRoleMgmt').classList.add('update-btn'); document.getElementById('btnCancelEditNodeRoleMgmt').classList.remove('hidden'); /* Switch to define tab */ activateTab('tab-define'); document.getElementById('newNodeRoleName').focus(); }
    function cancelEditNodeRoleMgmt() { editingNodeRoleKeyMgmt = null; document.getElementById('newNodeRoleName').value = ''; document.getElementById('newNodeRoleColor').value = '#4A90E2'; document.getElementById('newNodeRoleShape').value = 'circle'; document.getElementById('nodeRoleFormTitleMgmt').textContent = 'New/Edit Role Type'; document.getElementById('btnSaveNodeRoleMgmt').textContent = 'Add Role Type'; document.getElementById('btnSaveNodeRoleMgmt').classList.remove('update-btn'); document.getElementById('btnCancelEditNodeRoleMgmt').classList.add('hidden'); }
    function handleDeleteNodeRoleMgmt(roleKey) { if (!nodeRoleStyles[roleKey] || nodeRoleStyles[roleKey].isDeletable === false) { alert(`Role "${nodeRoleStyles[roleKey]? nodeRoleStyles[roleKey].name : roleKey}" cannot be deleted.`); return; } if (!confirm(`Delete role "${nodeRoleStyles[roleKey].name}"? Nodes revert to 'Individual Contributor'.`)) return; try { var defaultRoleKey = 'ic'; if (!nodeRoleStyles[defaultRoleKey]) { nodeRoleStyles[defaultRoleKey] = { name: 'Individual Contributor', color: '#CCCCCC', shape: 'circle', isDeletable: false }; } var nodesToReassign = []; nodes.get().forEach(node => { if (node.role === roleKey) { var groupInfo = nodeGroupStyles[node.group] || nodeGroupStyles['general']; var newRoleInfo = nodeRoleStyles[defaultRoleKey]; nodesToReassign.push({ id: node.id, role: defaultRoleKey, shape: newRoleInfo.shape, color: { border: newRoleInfo.color }, title: (node.originalLabel || node.label.replace(/\n/g, ' ')) + ` (Dept: ${groupInfo.name}, Role: ${newRoleInfo.name})` }); } }); if (nodesToReassign.length > 0) nodes.update(nodesToReassign); delete nodeRoleStyles[roleKey]; renderAllListsAndLegends(); populateNodeRoleDropdown(); if (editingNodeRoleKeyMgmt === roleKey) cancelEditNodeRoleMgmt(); } catch (e) { console.error("Error deleting node role:", roleKey, e); } }


    // --- Relationship Type Definition Management ---
    function handleSaveRelTypeMgmt(){console.log('handleSaveRelTypeMgmt. Editing ID:',editingRelTypeIdMgmt);var nIn=document.getElementById('newRelTypeName'),cIn=document.getElementById('newRelTypeColor');var arrowSel=document.getElementById('newRelArrowStyle');var showLabelCheck=document.getElementById('newRelShowLabel');var labelAlignSel=document.getElementById('newRelLabelAlign');var typeName=nIn.value.trim(),color=cIn.value,arrowStyle=arrowSel.value;var showLabel=showLabelCheck.checked;var labelAlign=labelAlignSel.value;if(!typeName){alert('Relationship Type Label req.');return}var typeToUpd=null,origId=editingRelTypeIdMgmt;if(origId){typeToUpd=edgeTypeStyles.find(t=>t.id===origId);if(!typeToUpd){console.error("Cannot find rel type to update:",origId);cancelEditRelTypeMgmt();return}console.log("Updating existing rel type:",typeToUpd)}else{var newId=sanitizeKey(typeName);if(!newId){alert('Invalid Type Name.');return}if(edgeTypeStyles.find(t=>t.id===newId)){alert(`Relationship ID "${newId}" exists.`);return}typeToUpd={id:newId,isDeletable:true};edgeTypeStyles.push(typeToUpd);console.log("Adding new rel type:",typeToUpd)}typeToUpd.label=typeName;typeToUpd.color=color;typeToUpd.arrowStyle=arrowStyle;typeToUpd.showLabelOnDiagram=showLabel;typeToUpd.labelAlign=labelAlign;typeToUpd.isDeletable = typeToUpd.isDeletable !== false; if(origId){var edgesToModifyStyle=[];var affectedPairs=new Set();edges.get().forEach(e=>{if(e.visjs_edge_type_id===origId){ const showLabelActual = e.label !== undefined && e.label !== null; const newLabelContent = showLabelActual ? typeName : undefined; const newFontAlign = showLabelActual ? labelAlign : undefined; const newArrows = mapArrowStyleToVisOptions(arrowStyle); edgesToModifyStyle.push({ id:e.id, label: newLabelContent, font:{size:10,align: newFontAlign}, color:{color:color}, arrows: newArrows }); affectedPairs.add(JSON.stringify([e.from,e.to].sort()))}});if(edgesToModifyStyle.length>0){try{edges.update(edgesToModifyStyle);console.log(`Updated style of ${edgesToModifyStyle.length} edges for type ${origId}`)}catch(e){console.error("Err updating edges during type save:",e)}}affectedPairs.forEach(pairStr=>{try{const pair=JSON.parse(pairStr);reapplySmoothToParallelEdges(pair[0],pair[1])}catch(e){console.error("Error parsing pair for resmooth:",pairStr,e)}})}renderAllListsAndLegends();populateEdgeTypeDropdown();cancelEditRelTypeMgmt()}
    function prepareEditRelTypeMgmt(typeId){console.log("prepareEditRelTypeMgmt for ID:",typeId);var type=edgeTypeStyles.find(t=>t.id===typeId);if(!type){console.error("Relationship type not found for edit:",typeId);return}editingRelTypeIdMgmt=typeId;document.getElementById('newRelTypeName').value=type.label;document.getElementById('newRelTypeColor').value=type.color;document.getElementById('newRelArrowStyle').value=type.arrowStyle||'bi';var showLabelCheckbox=document.getElementById('newRelShowLabel');var labelAlignDropdown=document.getElementById('newRelLabelAlign');showLabelCheckbox.checked=type.showLabelOnDiagram!==false;labelAlignDropdown.value=type.labelAlign||'middle';labelAlignDropdown.disabled=!showLabelCheckbox.checked; if(showLabelCheckbox) { showLabelCheckbox.onchange=function(){ if(labelAlignDropdown) labelAlignDropdown.disabled=!this.checked; }; } document.getElementById('relTypeFormTitleMgmt').textContent='Edit Relationship Type';document.getElementById('btnSaveRelTypeMgmt').textContent='Update Relationship Type';document.getElementById('btnSaveRelTypeMgmt').classList.add('update-btn');document.getElementById('btnCancelEditRelTypeMgmt').classList.remove('hidden'); /* Switch to define tab */ activateTab('tab-define'); document.getElementById('newRelTypeName').focus();}
    function cancelEditRelTypeMgmt(){editingRelTypeIdMgmt=null;document.getElementById('newRelTypeName').value='';document.getElementById('newRelTypeColor').value='#808080';document.getElementById('newRelArrowStyle').value='bi';var showLabelCheckbox=document.getElementById('newRelShowLabel');var labelAlignDropdown=document.getElementById('newRelLabelAlign');if(showLabelCheckbox) showLabelCheckbox.checked=false; if(labelAlignDropdown){ labelAlignDropdown.value='middle'; labelAlignDropdown.disabled=true;} if(showLabelCheckbox)showLabelCheckbox.onchange=null;document.getElementById('relTypeFormTitleMgmt').textContent='New/Edit Relationship Type';document.getElementById('btnSaveRelTypeMgmt').textContent='Add Relationship Type';document.getElementById('btnSaveRelTypeMgmt').classList.remove('update-btn');document.getElementById('btnCancelEditRelTypeMgmt').classList.add('hidden');console.log("Rel type edit cancelled.")}
    function handleDeleteRelTypeMgmt(typeId){var typeDel=edgeTypeStyles.find(t=>t.id===typeId);if(!typeDel||typeDel.isDeletable===false){alert(typeDel?`Relationship type "${typeDel.label}" cannot be deleted.`:'This relationship type cannot be deleted.');return}if(!confirm(`Delete "${typeDel.label}"? All related edges WILL BE DELETED.`))return;try{var affectedPairs=new Set();var edgesToRemove=edges.get({filter:e=>e.visjs_edge_type_id===typeId});edgesToRemove.forEach(e=>affectedPairs.add(JSON.stringify([e.from,e.to].sort())));if(edgesToRemove.length>0)edges.remove(edgesToRemove.map(e=>e.id));edgeTypeStyles=edgeTypeStyles.filter(t=>t.id!==typeId);renderAllListsAndLegends();populateEdgeTypeDropdown();affectedPairs.forEach(pairStr=>{try{const pair=JSON.parse(pairStr);reapplySmoothToParallelEdges(pair[0],pair[1])}catch(e){console.error("Error parsing pair for resmooth on delete rel type:",pairStr,e)}});if(editingRelTypeIdMgmt===typeId)cancelEditRelTypeMgmt()}catch(e){console.error("Err del rel type def:",typeId,e)}}


    // --- UI Rendering (Lists, Legends, Dropdowns) ---
    function populateNodeGroupDropdown(){var s=document.getElementById('nodeGroup');if(!s)return; var currentVal = s.value; s.innerHTML='';Object.keys(nodeGroupStyles).sort((a,b)=>nodeGroupStyles[a].name.localeCompare(nodeGroupStyles[b].name)).forEach(k=>{if(!nodeGroupStyles.hasOwnProperty(k))return;var o=document.createElement('option');o.value=k;o.textContent=nodeGroupStyles[k].name;s.appendChild(o)}); s.value = currentVal; if(!s.value && s.options.length > 0) { s.selectedIndex = 0; } }
    function populateEdgeTypeDropdown(){var s=document.getElementById('edgeType');if(!s)return; var currentVal = s.value; s.innerHTML='';edgeTypeStyles.sort((a,b)=>a.label.localeCompare(b.label)).forEach(t=>{var o=document.createElement('option');o.value=t.id;o.textContent=t.label;s.appendChild(o)}); s.value = currentVal; if (s.options.length > 0 && !s.value) { s.selectedIndex = 0; } updateEdgeOverridesFromType(); }
    function populateNodeRoleDropdown() { var select = document.getElementById('nodeRole'); if(!select) return; var currentVal = select.value; select.innerHTML = ''; Object.keys(nodeRoleStyles).sort((a,b)=>nodeRoleStyles[a].name.localeCompare(nodeRoleStyles[b].name)).forEach(key => { var option = document.createElement('option'); option.value = key; option.textContent = nodeRoleStyles[key].name; select.appendChild(option); }); select.value = currentVal; if(!select.value && select.options.length > 0) { select.selectedIndex = 0; } }
    function updateNodeSelectors(){var sF=document.getElementById('edgeFrom'),sT=document.getElementById('edgeTo');if(!sF||!sT)return;var cF=sF.value,cT=sT.value;sF.innerHTML='<option value="">-- Select --</option>';sT.innerHTML='<option value="">-- Select --</option>';if(nodes&&typeof nodes.get==='function'){nodes.get({order:'originalLabel'}).forEach(n=>{var o=document.createElement('option');o.value=n.id;o.textContent=(n.originalLabel||n.label.replace(/\n/g,' '));sF.appendChild(o.cloneNode(true));sT.appendChild(o.cloneNode(true))});if(nodes.get(cF))sF.value=cF;else sF.value="";if(nodes.get(cT))sT.value=cT;else sT.value=""}}
    function renderNodeList(){var d=document.getElementById('nodeList');if(!d)return;d.innerHTML='';var allN=nodes?nodes.get({order:'originalLabel'}):[];if(allN.length===0){d.innerHTML='<em>No people added.</em>';return}allN.forEach(n=>{var i=document.createElement('div');i.className='list-item';var gI=(n.group&&nodeGroupStyles[n.group])?nodeGroupStyles[n.group]:nodeGroupStyles['general'];var gN=gI?gI.name:'N/A';var rI=(n.role&&nodeRoleStyles[n.role])?nodeRoleStyles[n.role]:nodeRoleStyles['ic'];var rN=rI?rI.name:'N/A (Default)';var dispL=n.originalLabel||n.label.replace(/\n/g,' ');var ct=document.createElement('span');ct.className='list-item-content';ct.innerHTML=`<strong>${dispL}</strong> <small>(Dept: ${gN}, Role: ${rN})</small>`;i.appendChild(ct);var ac=document.createElement('span');ac.className='list-item-actions';var edB=document.createElement('button');edB.textContent='Edit';edB.className='edit-btn';edB.onclick=function(){prepareEditNode(n.id)};ac.appendChild(edB);var dlB=document.createElement('button');dlB.textContent='X';dlB.className='delete-btn';dlB.onclick=function(){deleteNode(n.id)};ac.appendChild(dlB);i.appendChild(ac);d.appendChild(i)})}
    function renderEdgeList(){var d=document.getElementById('edgeList');if(!d)return;d.innerHTML='';var allE=edges?edges.get({order:'id'}):[];if(allE.length===0){d.innerHTML='<em>No relationships added.</em>';return}allE.forEach(e=>{var fN=nodes.get(e.from),tN=nodes.get(e.to);var i=document.createElement('div');i.className='list-item';var fL=fN?(fN.originalLabel||fN.label.replace(/\n/g,' ')):'?';var tL=tN?(tN.originalLabel||tN.label.replace(/\n/g,' ')):'?';var eT=edgeTypeStyles.find(t=>t.id===e.visjs_edge_type_id);var typeLabelForList=eT?eT.label:(e.label||'N/A'); var showLabelOnDiagramInList = (e.label !== undefined && e.label !== null); var listLabelSuffix = showLabelOnDiagramInList ? '' : ' (hidden)'; let arS='—'; if (e.arrows) { if (e.arrows.from && e.arrows.from.enabled && e.arrows.to && e.arrows.to.enabled) arS='↔'; else if (e.arrows.to && e.arrows.to.enabled) arS='→'; else if (e.arrows.from && e.arrows.from.enabled) arS='←'; } else if (eT) { if(eT.arrowStyle==='to')arS='→';else if(eT.arrowStyle==='bi')arS='↔'; } var strengthLabel = e.strength ? ` (${e.strength.charAt(0).toUpperCase() + e.strength.slice(1)})` : ''; var ct=document.createElement('span');ct.className='list-item-content';ct.innerHTML=`<strong>${fL}</strong> ${arS} <strong>${tL}</strong> <small>(${typeLabelForList}${listLabelSuffix}${strengthLabel})</small>`;i.appendChild(ct);var ac=document.createElement('span');ac.className='list-item-actions';var edB=document.createElement('button');edB.textContent='Edit';edB.className='edit-btn';edB.onclick=function(){prepareEditEdge(e.id)};ac.appendChild(edB);var dlB=document.createElement('button');dlB.textContent='X';dlB.className='delete-btn';dlB.onclick=function(){deleteEdge(e.id)};ac.appendChild(dlB);i.appendChild(ac);d.appendChild(i)})}
    function renderNodeGroupMgmtList(){var c=document.getElementById('nodeGroupMgmtList');if(!c)return;c.innerHTML='';Object.keys(nodeGroupStyles).sort((a,b)=>nodeGroupStyles[a].name.localeCompare(nodeGroupStyles[b].name)).forEach(k=>{var g=nodeGroupStyles[k];var i=document.createElement('div');i.className='mgmt-list-item';var ct=document.createElement('span');ct.className='mgmt-list-item-content';var sw=document.createElement('span');sw.className='mgmt-list-color-swatch';sw.style.backgroundColor=g.color.background;sw.style.borderColor=g.color.border;ct.appendChild(sw);ct.append(`${g.name} (Key: ${k})`);i.appendChild(ct);var ac=document.createElement('span');ac.className='mgmt-list-item-actions'; var edB=document.createElement('button');edB.textContent='Edit';edB.className='edit-btn';edB.onclick=function(){prepareEditNodeGroupMgmt(k)};ac.appendChild(edB); if(g.isDeletable!==false){var dlB=document.createElement('button');dlB.textContent='Del';dlB.className='delete-btn';dlB.onclick=function(){handleDeleteNodeGroupMgmt(k)};ac.appendChild(dlB)}i.appendChild(ac);c.appendChild(i)})}
    function renderNodeRoleMgmtList() { var container = document.getElementById('nodeRoleMgmtList'); if (!container) return; container.innerHTML = ''; Object.keys(nodeRoleStyles).sort((a,b)=>nodeRoleStyles[a].name.localeCompare(nodeRoleStyles[b].name)).forEach(key => { var role = nodeRoleStyles[key]; var item = document.createElement('div'); item.className = 'mgmt-list-item'; var content = document.createElement('span'); content.className = 'mgmt-list-item-content'; var swatch = document.createElement('span'); swatch.className = 'mgmt-list-color-swatch'; swatch.style.backgroundColor = role.color; swatch.style.border = '1px solid #555'; var shapeDisplay = document.createElement('span'); shapeDisplay.className = 'legend-node-shape-box'; shapeDisplay.style.borderColor = role.color; shapeDisplay.style.backgroundColor = '#eee'; shapeDisplay.style.borderWidth = '2px'; if (role.shape === 'circle' || role.shape === 'ellipse') shapeDisplay.style.borderRadius = '50%'; else if (role.shape === 'box' || role.shape === 'square') shapeDisplay.style.borderRadius = '0'; else if (role.shape === 'diamond') { shapeDisplay.style.transform = 'rotate(45deg)'; shapeDisplay.style.borderRadius = '0'; } else if (role.shape === 'star') { shapeDisplay.innerHTML = '★'; shapeDisplay.style.border = 'none'; shapeDisplay.style.color = role.color; shapeDisplay.style.fontSize = '16px'; shapeDisplay.style.lineHeight = '16px'; shapeDisplay.style.textAlign = 'center'; shapeDisplay.style.backgroundColor='transparent'; } else shapeDisplay.style.borderRadius = '50%'; content.appendChild(swatch); content.appendChild(shapeDisplay); content.append(` ${role.name} (Key: ${key})`); item.appendChild(content); var actions = document.createElement('span'); actions.className = 'mgmt-list-item-actions'; var editButton = document.createElement('button'); editButton.textContent = 'Edit'; editButton.className = 'edit-btn'; editButton.onclick = function() { prepareEditNodeRoleMgmt(key); }; actions.appendChild(editButton); if (role.isDeletable !== false) { var deleteButton = document.createElement('button'); deleteButton.textContent = 'Del'; deleteButton.className = 'delete-btn'; deleteButton.onclick = function() { handleDeleteNodeRoleMgmt(key); }; actions.appendChild(deleteButton); } item.appendChild(actions); container.appendChild(item); }); }
    function renderRelTypeMgmtList(){var c=document.getElementById('relTypeMgmtList');if(!c)return;c.innerHTML='';edgeTypeStyles.sort((a,b)=>a.label.localeCompare(b.label)).forEach(t=>{var i=document.createElement('div');i.className='mgmt-list-item';var ct=document.createElement('span');ct.className='mgmt-list-item-content';var sw=document.createElement('span');sw.className='mgmt-list-color-swatch';sw.style.backgroundColor=t.color;ct.appendChild(sw);let ar='—';if(t.arrowStyle==='to')ar='→';else if(t.arrowStyle==='bi')ar='↔';let lblInfo=t.showLabelOnDiagram!==false?`Lbl Shown (Align: ${t.labelAlign||'mid'})`:'Lbl Hidden';ct.append(`${t.label} (${ar}), ${lblInfo}, (ID: ${t.id})`);i.appendChild(ct);var ac=document.createElement('span');ac.className='mgmt-list-item-actions';var edB=document.createElement('button');edB.textContent='Edit';edB.className='edit-btn';edB.onclick=function(){prepareEditRelTypeMgmt(t.id)};ac.appendChild(edB);if(t.isDeletable!==false){var dlB=document.createElement('button');dlB.textContent='Del';dlB.className='delete-btn';dlB.onclick=function(){handleDeleteRelTypeMgmt(t.id)};ac.appendChild(dlB)}i.appendChild(ac);c.appendChild(i)})}
    function populateNodeLegend(){var c=document.getElementById('nodeLegend');if(!c)return;var h=c.querySelector('h3')||document.createElement('h3');h.textContent='Node Depts. (Fill)';c.innerHTML='';c.appendChild(h);Object.keys(nodeGroupStyles).sort((a,b)=>nodeGroupStyles[a].name.localeCompare(nodeGroupStyles[b].name)).forEach(k=>{if(!nodeGroupStyles.hasOwnProperty(k))return;var g=nodeGroupStyles[k];var i=document.createElement('div');i.className='legend-item';var b=document.createElement('span');b.className='legend-node-color-box'; b.style.borderRadius = '50%'; b.style.backgroundColor=g.color.background;b.style.borderColor='transparent'; b.style.borderWidth = '0'; var t=document.createElement('span');t.className='legend-text';t.textContent=g.name;i.appendChild(b);i.appendChild(t);c.appendChild(i);})}
    function populateRoleLegend() { // Uses the updated version from previous step
         var container = document.getElementById('roleLegend'); if (!container) return;
         var h3 = container.querySelector('h3') || document.createElement('h3');
         h3.textContent = 'Node Roles (Shape & Outline)'; // Updated title slightly
         container.innerHTML = ''; container.appendChild(h3);

         Object.keys(nodeRoleStyles).sort((a, b) => nodeRoleStyles[a].name.localeCompare(nodeRoleStyles[b].name)).forEach(key => {
             var role = nodeRoleStyles[key];
             var item = document.createElement('div');
             item.className = 'legend-item';

             // Create ONE symbol combining shape and border color
             var shapeDisplay = document.createElement('span');
             shapeDisplay.className = 'legend-node-shape-box'; // Use existing class for size/margins
             shapeDisplay.style.display = 'inline-block';
             // Apply role-specific styles
             shapeDisplay.style.backgroundColor = '#ffffff'; // Use white background for better border visibility
             shapeDisplay.style.borderColor = role.color;
             shapeDisplay.style.borderWidth = '2px'; // Keep border width consistent

            // Apply shape styling
             if (role.shape === 'circle' || role.shape === 'ellipse') {
                 shapeDisplay.style.borderRadius = '50%';
             } else if (role.shape === 'box' || role.shape === 'square') {
                 shapeDisplay.style.borderRadius = '2px'; // Slight rounding for boxes
             } else if (role.shape === 'database') {
                // Approximation for legend: cylinder-like
                 shapeDisplay.style.borderRadius = '50% / 20%';
                 shapeDisplay.style.height = '18px'; // Adjust height slightly
             } else if (role.shape === 'diamond') {
                 shapeDisplay.style.borderRadius = '0';
                 shapeDisplay.style.transform = 'rotate(45deg)';
                 shapeDisplay.style.marginTop = '3px'; shapeDisplay.style.marginBottom = '3px'; // Adjust spacing for diamond
             } else if (role.shape === 'star') {
                 // Represent star with character (simplification for legend)
                 shapeDisplay.innerHTML = '★';
                 shapeDisplay.style.border = 'none';
                 shapeDisplay.style.color = role.color;
                 shapeDisplay.style.fontSize = '18px'; // Slightly larger star
                 shapeDisplay.style.lineHeight = '16px';
                 shapeDisplay.style.textAlign = 'center';
                 shapeDisplay.style.backgroundColor = 'transparent';
                 shapeDisplay.style.width = '18px'; // Adjust width for star
                 shapeDisplay.style.verticalAlign = 'middle';
             } else if (role.shape === 'triangle' || role.shape === 'triangleDown'){
                 // Represent triangle with character
                 shapeDisplay.innerHTML = (role.shape === 'triangle' ? '▲' : '▼');
                 shapeDisplay.style.border = 'none';
                 shapeDisplay.style.color = role.color;
                 shapeDisplay.style.fontSize = '18px';
                 shapeDisplay.style.lineHeight = '16px';
                 shapeDisplay.style.textAlign = 'center';
                 shapeDisplay.style.backgroundColor = 'transparent';
                 shapeDisplay.style.width = '18px';
                 shapeDisplay.style.verticalAlign = 'middle';
             } else if (role.shape === 'hexagon') {
                 // Cannot easily do hexagon with CSS border-radius, represent as circle
                  shapeDisplay.style.borderRadius = '50%';
                  shapeDisplay.title = 'Hexagon (shown as circle)'; // Tooltip
             } else if (role.shape === 'text') {
                 // Represent text with T
                 shapeDisplay.innerHTML = 'T';
                 shapeDisplay.style.border = `2px solid ${role.color}`;
                 shapeDisplay.style.color = role.color;
                 shapeDisplay.style.fontWeight = 'bold';
                 shapeDisplay.style.fontSize = '12px';
                 shapeDisplay.style.lineHeight = '12px';
                 shapeDisplay.style.textAlign = 'center';
                 shapeDisplay.style.backgroundColor = '#ffffff';
                 shapeDisplay.style.borderRadius = '2px';
             }
              else { // Default: Circle
                 shapeDisplay.style.borderRadius = '50%';
             }

             var text = document.createElement('span');
             text.className = 'legend-text';
             text.textContent = `${role.name}`;

             item.appendChild(shapeDisplay); // Add the single combined symbol
             item.appendChild(text);
             container.appendChild(item);
         });
     }
    function populateEdgeLegend(){var c=document.getElementById('edgeLegend');if(!c)return;var h=c.querySelector('h3')||document.createElement('h3');h.textContent='Relationship Types (Color)';c.innerHTML='';c.appendChild(h);edgeTypeStyles.sort((a,b)=>a.label.localeCompare(b.label)).forEach(t=>{var i=document.createElement('div');i.className='legend-item';var l=document.createElement('span');l.className='legend-edge-color-line';l.style.backgroundColor=t.color; var s=document.createElement('span');s.className='legend-text';s.textContent=t.label;i.appendChild(l);i.appendChild(s);c.appendChild(i);})}

    // --- Image Export (Uses updated function from previous step) ---
     function exportDiagramWithLegend() {
        if (typeof html2canvas === 'undefined') {
            alert('html2canvas library is not loaded. Cannot export image with legend.');
            console.error('html2canvas not found.');
            return;
        }

        const networkElement = document.getElementById('mynetwork');
        const legendElement = document.getElementById('legendContainer'); // Legend is now in main content

        if (!networkElement || !legendElement) {
            alert("Could not find the network or legend elements to export.");
            console.error('Export elements not found.');
            return;
        }

        console.log("Attempting to capture network and legend separately...");

        let originalPhysicsState = visNetworkOptions.physics.enabled;
        if (originalPhysicsState && network) {
            network.setOptions({ physics: { enabled: false } });
            console.log("Physics temporarily disabled for export.");
        }

        // Slightly longer timeout to ensure layout stabilization
        setTimeout(() => {
            const scaleFactor = 2.0; // Keep high resolution
            const padding = 20 * scaleFactor; // Padding around elements and between them

            const html2canvasOptions = {
                allowTaint: true,
                useCORS: true,
                logging: false, // Reduce console noise
                scale: scaleFactor,
                backgroundColor: '#ffffff' // Ensure a white background
            };

            // 1. Capture the network
            const promiseNetwork = html2canvas(networkElement, html2canvasOptions)
                .catch(err => { console.error("Error capturing network:", err); throw err; }); // Ensure errors are propagated

            // 2. Capture the legend
            const promiseLegend = html2canvas(legendElement, html2canvasOptions)
                .catch(err => { console.error("Error capturing legend:", err); throw err; }); // Ensure errors are propagated

            // 3. Combine canvases when both captures are done
            Promise.all([promiseNetwork, promiseLegend])
                .then(([networkCanvas, legendCanvas]) => {
                    console.log("Both network and legend captured successfully.");

                    // Create a new combined canvas
                    const combinedCanvas = document.createElement('canvas');
                    const combinedCtx = combinedCanvas.getContext('2d');

                    // Calculate dimensions for the combined canvas
                    combinedCanvas.width = networkCanvas.width + legendCanvas.width + (padding * 2); // Network + Padding + Legend + Padding
                    combinedCanvas.height = Math.max(networkCanvas.height, legendCanvas.height) + (padding); // Max height + Padding

                    // Fill background
                    combinedCtx.fillStyle = '#ffffff';
                    combinedCtx.fillRect(0, 0, combinedCanvas.width, combinedCanvas.height);

                    // Draw the network canvas onto the combined canvas
                    combinedCtx.drawImage(networkCanvas, padding / 2, padding / 2 );

                    // Draw the legend canvas next to the network
                    combinedCtx.drawImage(legendCanvas, networkCanvas.width + padding, padding / 2 );

                    console.log("Canvases combined.");

                    // Trigger download
                    var dataURL = combinedCanvas.toDataURL('image/png');
                    var a = document.createElement('a');
                    a.href = dataURL;
                    a.download = 'network_with_legend.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    console.log("Combined image download initiated.");

                })
                .catch(error => {
                    console.error('Error during combined image export process:', error);
                    alert('Error exporting image. Check console for details.');
                })
                .finally(() => {
                    // Re-enable physics if it was originally enabled
                    if (originalPhysicsState && network) {
                        network.setOptions({ physics: { enabled: true } });
                        console.log("Physics re-enabled.");
                    }
                });

        }, 400); // Increased timeout to 400ms
    }

    // Helper function to activate a specific tab
    function activateTab(tabId) {
        document.querySelectorAll('.sidebar-tab-button').forEach(btn => {
            if (btn.getAttribute('data-tab') === tabId) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });
        document.querySelectorAll('.tab-panel').forEach(panel => {
            if (panel.id === tabId) {
                panel.classList.add('active');
            } else {
                panel.classList.remove('active');
            }
        });
        console.log("Activated tab:", tabId);
    }


</script>
</body>
</html>